> **[↩ 返回到目录](doc.md)**

---

### Go 垃圾回收器指南

#### 目录
*   介绍
*   Go 值的存储位置
*   追踪式垃圾回收
*   GC 周期
*   理解成本
*   GOGC
*   内存限制
*   延迟
*   Finalizers、清理和弱引用
*   额外资源
*   关于虚拟内存的说明
*   优化指南
*   识别成本
*   消除堆分配
*   特定于实现的优化
*   Linux 透明大页 (THP)
*   附录
*   关于 GOGC 的额外说明

#### 介绍
本文档旨在帮助 Go 程序员理解 Go 垃圾回收器（GC）的工作原理。它解释了 GC 的成本，并提供了优化 Go 程序性能的实用建议。

#### Go 值的存储位置
在深入 GC 之前，我们先讨论一下不需要由 GC 管理的内存。

Go 值可以存储在栈上或堆上。编译器会自动决定将值存储在何处。如果一个值的生命周期不会超出声明它的函数，编译器通常会将其分配在栈上。栈上的内存管理非常快，因为当函数返回时，该函数的整个栈帧（包括其所有局部变量）会一次性被移除。

如果一个值的生命周期超出了其声明函数的范围，编译器必须将其分配在堆上。例如，如果一个函数返回了一个指向局部变量的指针，或者将一个局部变量的指针存入了全局变量，那么这个值就不能留在栈上，因为栈帧在函数返回后会被销毁。堆上的内存由 GC 管理。

**通俗讲解**：想象一下，栈就像是一个临时的办公桌。你在上面放文件（变量），当你完成一个任务（函数调用）后，你把整个桌子清空（函数返回），所有文件都被丢弃。而堆则像是一个永久的文件柜。你可以把文件放进文件柜，然后在程序的任何地方通过索引（指针）来查找它。文件柜里的文件需要管理员（GC）来定期清理不再需要的文件。

#### 追踪式垃圾回收
Go 使用一种称为“追踪式垃圾回收”（Tracing Garbage Collection）的技术。这意味着 GC 会追踪程序中所有可达的对象。

所有对象和指向其他对象的指针共同构成了“对象图”（object graph）。为了识别哪些内存是存活的，GC 会从程序的“根”（roots）开始遍历对象图。根是指程序明确在使用的对象，例如局部变量和全局变量。遍历对象图的过程被称为“扫描”（scanning）。如果你在 Go 文档中看到“可达”（reachable）这个词，它指的就是可以通过扫描过程找到的对象。需要注意的是，一旦内存变得不可达，它就会一直保持不可达状态（有一个例外情况）。

一种你可能熟悉的替代技术是，实际将对象移动到内存的新位置，并在原地留下一个转发指针，之后用它来更新应用程序的所有指针。我们把这种会移动对象的 GC 称为“移动式 GC”（moving GC）；Go 使用的是“非移动式 GC”（non-moving GC）。

**通俗讲解**：想象一下，你有一大堆玩具（对象），有些玩具用绳子（指针）连着其他玩具。你从你手上拿着的几个玩具（根）开始，沿着绳子一个一个地找，所有你能找到的玩具都是“活”的。那些你找不到的玩具，就是“死”的，可以被回收了。Go 的 GC 不会把玩具从一个地方搬到另一个地方（非移动式），它只是标记哪些是活的，然后清理掉死的。

#### GC 周期
Go 的 GC 是一个并发的、三色的、标记-清除（mark-and-sweep）收集器。它的周期由三个阶段组成：

1.  **标记（Marking）**：GC 扫描对象图，找出所有可达的对象并标记它们为“存活”。这个阶段是并发的，意味着它和你的程序代码（mutator）同时运行。
2.  **停止世界（Stop-the-world）**：在标记阶段结束时，程序会短暂暂停（通常很短），以便 GC 可以完成一些清理工作并准备进入下一个阶段。
3.  **清除（Sweeping）**：GC 回收所有未被标记的对象（即不可达的对象）所占用的内存。这个阶段也是并发的。

GC 会在这三个阶段（清除、关闭、标记）之间持续循环。

**通俗讲解**：可以把 GC 周期想象成一个循环的清洁流程：
1.  **标记**：清洁工（GC）开始工作，给所有还在使用的家具（存活对象）贴上“保留”标签。
2.  **暂停**：所有人（程序）短暂停止活动，让清洁工确认所有标签都贴好了。
3.  **清理**：清洁工开始清理，把没有标签的旧家具（死亡对象）扔掉。与此同时，你还可以继续使用贴了标签的家具。清理完一批后，流程重新开始。

#### 理解成本
要理解 GC 的成本，可以考虑以下三个基本公理：
1.  GC 只涉及两种资源：物理内存和 CPU 时间。
2.  GC 的工作量与堆上存活对象（live heap）的数量成正比。
3.  GC 的频率与程序的内存分配速率（allocation rate）成正比。

简单来说，你的程序分配内存越快，GC 就需要运行得越频繁。GC 运行时，会消耗 CPU 时间来扫描对象图和清理内存。

**通俗讲解**：成本就像水电费。你家的“活家具”越多（存活堆内存），清洁工（GC）每次来打扫的工作量就越大（CPU 成本）。你买新家具（分配内存）的速度越快，清洁工就需要来得越勤快（GC 频率），这会增加你的总“水电费”（CPU 和内存开销）。

#### GOGC
`GOGC` 是一个可以调整 GC 行为的关键参数。它定义了 GC 在下次运行前，堆内存可以增长多少的百分比。

例如，`GOGC=100`（默认值）意味着，当堆上存活对象的大小增长了 100% 时，GC 就会启动。如果当前存活堆是 100MB，那么当它增长到 200MB 时，GC 就会开始下一轮标记。

你可以通过 `GOGC` 环境变量或 `runtime/debug.SetGCPercent` API 来设置它。

*   **降低 `GOGC`**（例如 `GOGC=20`）：会让 GC 更频繁地运行，从而保持堆内存更小，但会消耗更多 CPU 时间。
*   **提高 `GOGC`**（例如 `GOGC=200`）：会让 GC 运行得更少，节省 CPU 时间，但会导致堆内存更大。

**通俗讲解**：`GOGC` 就像是你给清洁工定的打扫规则。`GOGC=100` 意味着“家里新增的杂物达到原来的一倍时，你就来打扫”。如果你把规则改成 `GOGC=20`（“新增杂物达到原来的20%就来打扫”），清洁工会来得更勤快，家里会更整洁（内存小），但清洁工的工资（CPU）会更高。反之，如果你改成 `GOGC=200`，清洁工来得少，工资省了，但家里会更乱（内存大）。

#### 内存限制
Go 1.19 引入了内存限制（Memory Limit）功能。你可以设置一个总的内存使用上限，GC 会尽力在这个限制内工作。这比单纯依赖 `GOGC` 更直接，因为它直接控制了内存占用。

#### 延迟
GC 可能会影响程序的延迟（Latency），即程序响应请求的速度。主要来源包括：
*   **短暂的“停止世界”暂停**：在 GC 周期切换时，程序会短暂暂停。
*   **调度延迟**：当 GC 在标记阶段运行时，它会占用一部分 CPU 资源（默认最多25%），这可能会延迟你的用户 goroutine。
*   **用户 goroutine 协助 GC**：当程序分配内存的速率非常高时，用户 goroutine 会被要求“帮忙”进行一些 GC 工作，这会增加它们的执行时间。

#### Finalizers、清理和弱引用
Go 提供了 `runtime.SetFinalizer`、`runtime.AddCleanup` 和 `weak.Pointer` 等功能，用于在对象被回收前执行清理代码或创建弱引用。但这些功能使用起来很微妙，容易出错，应尽量避免在普通代码中直接使用。

**通俗讲解**：`Finalizer` 就像是给一个要扔掉的玩具设置一个“销毁前仪式”。但这个仪式什么时候执行是不确定的，完全由清洁工（GC）决定。如果你依赖这个仪式来释放关键资源（比如关掉水龙头），可能会导致资源泄漏。因此，最好还是自己手动关掉水龙头（显式释放资源）。

#### 优化指南

**识别成本**
要优化 GC，首先要识别它带来的成本。
*   **CPU 剖析（CPU Profiling）**：使用 `go tool pprof` 查看 CPU 使用情况。如果 `runtime.mallocgc`（内存分配）或 `runtime.gcBgMarkWorker`（后台标记）等函数占用 CPU 较高，说明 GC 成本较高。
*   **堆剖析（Heap Profiling）**：使用 `go tool pprof --heap` 查看哪些代码分配了最多的内存。减少不必要的分配是降低 GC 成本最有效的方法。

**消除堆分配**
减少堆分配是优化性能的最佳途径。
*   **重用对象**：使用 `sync.Pool` 来缓存和重用对象，避免重复创建和销毁。
*   **优化数据结构**：使用更紧凑的数据结构，例如用 `[]int` 代替 `[]*int`，因为指针会增加 GC 扫描的开销。
*   **栈分配**：编写代码时，尽量让变量的生命周期短，这样编译器更有可能将其分配在栈上。

**特定于实现的优化**
*   **Linux 透明大页 (THP)**：在某些工作负载下，禁用 THP 可以减少 GC 的延迟。

---

> **[↩ 返回到目录](doc.md)**
