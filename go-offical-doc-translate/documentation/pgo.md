> **[↩ 返回到目录](doc.md)**
---

### **基于配置文件的优化 (Profile-guided optimization)**

从 Go 1.20 版本开始，Go 编译器支持基于配置文件的优化（Profile-guided optimization, PGO），以进一步优化构建。

**目录：**
*   概述
*   收集配置文件
*   使用 PGO 构建
*   注意事项
*   常见问题
*   附录：其他配置文件来源

---

#### **概述**

基于配置文件的优化（PGO），也称为反馈导向优化（FDO），是一种编译器优化技术。该技术将应用程序代表性运行时收集到的信息（即配置文件）反馈给编译器，用于下一次应用程序的构建。编译器利用这些信息做出更明智的优化决策。例如，编译器可能会更积极地内联配置文件中显示被频繁调用的函数。

在 Go 语言中，编译器使用 CPU 的 pprof 配置文件作为输入，例如来自 `runtime/pprof` 或 `net/http/pprof` 的配置文件。

截至 Go 1.22 版本，对一组代表性 Go 程序的基准测试表明，使用 PGO 构建可将性能提高约 2-14%。我们预计，随着未来 Go 版本中更多优化利用 PGO，性能提升将普遍增加。

---

#### **收集配置文件**

Go 编译器期望使用 CPU pprof 配置文件作为 PGO 的输入。Go 运行时生成的配置文件（例如来自 `runtime/pprof` 和 `net/http/pprof` 的）可以直接用作编译器的输入。也可能可以使用或转换来自其他分析系统的配置文件。请参阅附录了解更多信息。

为了获得最佳效果，配置文件必须能代表应用程序在生产环境中的实际行为。使用不具代表性的配置文件，很可能导致生成的二进制文件在生产环境中几乎没有性能提升。因此，**强烈建议直接从生产环境收集配置文件**，这也是 Go 的 PGO 设计的主要方法。

典型的流程如下：
1.  构建并发布一个初始二进制文件（不使用 PGO）。
2.  从生产环境中收集配置文件。
3.  当需要发布更新的二进制文件时，使用最新的源代码构建，并提供生产环境的配置文件。
4.  回到步骤 2。

Go 的 PGO 对配置文件版本与正在构建的源代码版本之间的差异，以及从已优化的二进制文件收集的配置文件，都具有很强的鲁棒性。这使得上述迭代生命周期成为可能。有关此工作流程的更多细节，请参阅“AutoFDO”部分。

如果很难或无法从生产环境收集（例如，分发给最终用户的命令行工具），也可以从一个有代表性的基准测试中收集。请注意，构建有代表性的基准测试通常非常困难（并且随着应用程序的演变，保持其代表性也很困难）。特别是，微基准测试（microbenchmarks）通常不是 PGO 分析的好选择，因为它们只测试应用程序的一小部分，将其应用于整个程序时收益甚微。

---

#### **使用 PGO 构建**

标准的构建方法是将 pprof CPU 配置文件存储在被分析二进制文件的主包目录中，文件名为 `default.pgo`。默认情况下，`go build` 会自动检测 `default.pgo` 文件并启用 PGO。

**建议将配置文件直接提交到源代码仓库中**，因为配置文件是构建的重要输入，对构建的可重复性（以及高性能！）至关重要。将配置文件与源代码一起存储可以简化构建体验，除了获取源代码外，无需额外步骤来获取配置文件。

对于更复杂的场景，`go build -pgo` 标志可以控制 PGO 配置文件的选择。此标志默认为 `-pgo=auto`，对应上述 `default.pgo` 的行为。将标志设置为 `-pgo=off` 可完全禁用 PGO 优化。

如果您不能使用 `default.pgo`（例如，同一个二进制文件在不同场景下需要不同的配置文件，或无法将配置文件与源代码存储在一起等），您可以直接传递配置文件的路径（例如 `go build -pgo=/tmp/foo.pprof`）。

**注意**：传递给 `-pgo` 的路径适用于所有主包。例如，`go build -pgo=/tmp/foo.pprof ./cmd/foo ./cmd/bar` 会将 `foo.pprof` 应用于 `foo` 和 `bar` 两个二进制文件，而这通常不是您想要的。通常，不同的二进制文件应该有不同的配置文件，需要通过单独的 `go build` 命令来传递。

**注意**：在 Go 1.21 之前，默认值是 `-pgo=off`。必须显式启用 PGO。

---

#### **注意事项**

##### **从生产环境收集有代表性的配置文件**

如“收集配置文件”部分所述，您的生产环境是获取应用程序有代表性配置文件的最佳来源。

开始使用的最简单方法是在您的应用程序中添加 `net/http/pprof`，然后从服务的任意实例获取 `/debug/pprof/profile?seconds=30`。这是一个很好的起点，但这种方式可能存在不具代表性的情况：
*   获取配置文件时，该实例可能恰好没有在处理任何任务，尽管它通常很繁忙。
*   一天中的流量模式可能会变化，导致行为也随之改变。
*   实例可能执行长时间运行的操作（例如，5分钟执行操作A，然后5分钟执行操作B）。30秒的配置文件很可能只覆盖一种操作类型。
*   实例收到的请求分布可能不均衡（某些实例收到的某种类型请求比其他实例多）。

更稳健的策略是从不同时间、不同实例收集多个配置文件，以限制单个实例配置文件差异的影响。然后，可以将多个配置文件合并成一个用于 PGO 的单一配置文件。

许多组织运行“持续分析”（continuous profiling）服务，可以自动执行这种全集群范围的采样分析，这些服务可以作为 PGO 配置文件的来源。

##### **合并配置文件**

`pprof` 工具可以像这样合并多个配置文件：
```bash
$ go tool pprof -proto a.pprof b.pprof > merged.pprof
```
这种合并本质上是将输入配置文件中的样本进行直接求和，与配置文件的运行时长无关。因此，在对应用程序的短时间切片进行分析时（例如，无限期运行的服务器），您可能希望确保所有配置文件具有相同的运行时长（即所有配置文件都收集30秒）。否则，运行时长较长的配置文件在合并后的配置文件中会被过度代表。

##### **AutoFDO**

Go PGO 的设计支持一种“AutoFDO”风格的工作流程。

让我们仔细看看“收集配置文件”部分描述的流程：
1.  构建并发布一个初始二进制文件（不使用 PGO）。
2.  从生产环境中收集配置文件。
3.  当需要发布更新的二进制文件时，使用最新的源代码构建，并提供生产环境的配置文件。
4.  回到步骤 2。

这听起来很简单，但有几个重要特性需要注意：
*   开发是持续进行的，因此被分析的二进制文件版本（步骤2）的源代码可能与正在构建的最新源代码（步骤3）略有不同。Go PGO 设计上对此具有鲁棒性，我们称之为**源码稳定性**。
*   这是一个闭环。也就是说，经过第一次迭代后，被分析的二进制文件已经是使用前一次迭代的配置文件进行 PGO 优化的。Go PGO 也对此具有鲁棒性，我们称之为**迭代稳定性**。

**源码稳定性**是通过启发式方法将配置文件中的样本与正在编译的源代码进行匹配来实现的。因此，许多源代码更改（例如添加新函数）不会影响现有代码的匹配。当编译器无法匹配已更改的代码时，一些优化机会会丢失，但请注意，这是一种平缓的退化。单个函数匹配失败可能会失去优化机会，但整体 PGO 的收益通常分布在许多函数上。有关匹配和退化的更多详细信息，请参阅“源码稳定性”部分。

**迭代稳定性**是为了防止在连续的 PGO 构建中出现性能波动的循环（例如，构建#1很快，构建#2变慢，构建#3又变快等）。我们使用 CPU 配置文件来识别热点函数以进行优化。理论上，一个热点函数可能被 PGO 加速得如此之快，以至于在下一次配置文件中不再显得“热”，从而得不到优化，导致它再次变慢。Go 编译器对 PGO 优化采取了保守的方法，我们相信这可以防止显著的性能波动。如果您确实观察到这种不稳定性，请在 go.dev/issue/new 提交问题。

**源码稳定性和迭代稳定性共同消除了对两阶段构建的需求**，即先构建一个未优化的版本作为金丝雀（canary）进行分析，然后再用 PGO 重新构建用于生产（除非绝对需要峰值性能）。

##### **源码稳定性和重构**

如上所述，Go 的 PGO 会尽最大努力继续将旧配置文件中的样本与当前源代码进行匹配。具体来说，Go 使用函数内的行偏移量（例如，函数 `foo` 的第5行调用）。

许多常见的更改不会破坏匹配，包括：
*   在热点函数之外的文件中进行更改（在函数上方或下方添加/更改代码）。
*   将函数移动到同一包中的另一个文件（编译器完全忽略源文件名）。

一些可能破坏匹配的更改：
*   在热点函数内部进行更改（可能影响行偏移量）。
*   重命名函数（以及方法的类型）（更改了符号名）。
*   将函数移动到另一个包（更改了符号名）。

如果配置文件相对较新，那么差异可能只影响少数几个热点函数，从而限制了匹配失败函数的优化机会损失。尽管如此，随着时间推移，由于代码很少会重构回旧形式，这种性能退化会缓慢累积，因此定期收集新配置文件以限制与生产环境的源码偏差非常重要。

当进行大规模重构，重命名大量函数或将它们在包之间移动时，配置文件匹配可能会显著退化。在这种情况下，您可能会在短期内遇到性能下降，直到新的配置文件反映出新的代码结构。

对于简单的重命名，理论上可以重写现有配置文件，将旧的符号名更改为新名。`github.com/google/pprof/profile` 包包含了以这种方式重写 pprof 配置文件所需的原语，但截至目前，还没有现成的工具可用于此目的。

##### **新代码的性能**

当添加新代码或通过功能开关（flag flip）启用新的代码路径时，这些代码在第一次构建时不会出现在配置文件中，因此在收集到反映新代码的新配置文件之前，它们不会获得 PGO 优化。在评估新代码的上线时，请记住，初始版本的性能并不代表其稳定状态的性能。

---

#### **常见问题**

##### **是否可以使用 PGO 优化 Go 标准库包？**

**是的**。Go 的 PGO 适用于整个程序。所有包都会被重新构建以考虑潜在的基于配置文件的优化，包括标准库包。

##### **是否可以使用 PGO 优化依赖模块中的包？**

**是的**。Go 的 PGO 适用于整个程序。所有包都会被重新构建以考虑潜在的基于配置文件的优化，包括依赖项中的包。这意味着您的应用程序使用依赖项的独特方式会影响应用于该依赖项的优化。

##### **使用不具代表性的配置文件进行 PGO 会使我的程序比不使用 PGO 更慢吗？**

**不应该**。虽然一个不能代表生产环境行为的配置文件会导致在应用程序的冷代码部分进行优化，但它不应该让热点部分变得更慢。如果您遇到使用 PGO 后性能比禁用 PGO 更差的程序，请在 go.dev/issue/new 提交问题。

##### **我可以对不同的 GOOS/GOARCH 构建使用相同的配置文件吗？**

**可以**。配置文件的格式在不同的操作系统和架构配置下是等效的，因此可以在不同配置之间使用。例如，从 `linux/arm64` 二进制文件收集的配置文件可以在 `windows/amd64` 构建中使用。

话虽如此，上述讨论的源码稳定性注意事项在这里也同样适用。任何在这些配置之间不同的源代码将不会被优化。对于大多数应用程序，绝大部分代码是平台无关的，因此这种形式的性能退化是有限的。

一个具体的例子是，`os` 包中的文件处理内部实现因 Linux 和 Windows 而异。如果这些函数在 Linux 配置文件中是热点，那么 Windows 上的等效函数将不会获得 PGO 优化，因为它们与配置文件不匹配。

您可以合并不同 GOOS/GOARCH 构建的配置文件。请参阅下一个问题，了解这样做的权衡。

##### **如何处理用于不同工作负载类型的单个二进制文件？**

这里没有明显的最佳选择。用于不同类型工作负载的单个二进制文件（例如，一个数据库在一个服务中以读取为主，在另一个服务中以写入为主）可能有不同的热点组件，从而受益于不同的优化。

有三种选择：
1.  **为每种工作负载构建不同版本的二进制文件**：使用每种工作负载的配置文件来构建多个针对特定工作负载的二进制文件。这将为每种工作负载提供最佳性能，但可能会增加操作复杂性，例如处理多个二进制文件和配置文件来源。
2.  **为“最重要”的工作负载构建单个二进制文件**：选择“最重要”的工作负载（占用资源最多、对性能最敏感），并仅使用该工作负载的配置文件来构建。这将为选定的工作负载提供最佳性能，并且由于对跨工作负载共享的公共代码进行了优化，其他工作负载也可能获得适度的性能提升。
3.  **合并不同工作负载的配置文件**：获取每种工作负载的配置文件（按总占用资源加权），并将它们合并成一个单一的“全集群”配置文件，用于构建一个通用的二进制文件。这可能会为所有工作负载带来适度的性能提升。

##### **PGO 如何影响构建时间？**

启用 PGO 构建可能会导致包的构建时间明显增加。最明显的部分是，PGO 配置文件适用于二进制文件中的所有包，这意味着首次使用配置文件需要重新构建依赖图中的每个包。这些构建像其他构建一样会被缓存，因此使用相同配置文件的后续增量构建不需要完全重新构建。

如果您遇到构建时间极端增加的情况，请在 go.dev/issue/new 提交问题。

**注意**：编译器解析配置文件也可能增加显著的开销，特别是对于大型配置文件。使用大型配置文件和大型依赖图可能会显著增加构建时间。此问题已在 go.dev/issue/58102 中被跟踪，并将在未来的版本中解决。

##### **PGO 如何影响二进制文件大小？**

PGO 可能会导致二进制文件略微增大，这是由于额外的函数内联所致。

---

#### **附录：其他配置文件来源**

由 Go 运行时生成的 CPU 配置文件（通过 `runtime/pprof` 等）已经处于正确的格式，可直接用作 PGO 输入。然而，组织可能有其他首选工具（例如，Linux perf），或现有的全集群持续分析系统，他们希望将这些系统与 Go PGO 一起使用。

如果能将来自其他来源的配置文件转换为 pprof 格式，则可以与 Go PGO 一起使用，前提是满足以下一般要求：
*   其中一个样本索引的类型/单位应为 `"samples"/"count"` 或 `"cpu"/"nanoseconds"`。
*   样本应代表在采样位置的 CPU 时间样本。
*   配置文件必须是符号化的（`Function.name` 必须设置）。
*   样本必须包含内联函数的堆栈帧。如果省略内联函数，Go 将无法保持迭代稳定性。
*   必须设置 `Function.start_line`。这是函数开始的行号，即包含 `func` 关键字的行。Go 编译器使用此字段来计算样本的行偏移量（`Location.Line.line - Function.start_line`）。请注意，许多现有的 pprof 转换器会省略此字段。

**注意**：在 Go 1.21 之前，DWARF 元数据缺少函数起始行（`DW_AT_decl_line`），这可能使工具难以确定起始行。

有关特定第三方工具与 PGO 兼容性的更多信息，请参阅 Go Wiki 上的 PGO Tools 页面。

> **[↩ 返回到目录](doc.md)**