> **[↩ 返回到目录](doc.md)**


---

### 常见问题解答 (FAQ)

#### 起源

**这个项目的目的是什么？**

在2007年Go语言诞生之时，编程世界与今天大不相同。当时，生产软件通常使用C++或Java编写，GitHub还不存在，大多数计算机尚未配备多核处理器，除了Visual Studio和Eclipse之外，几乎没有可用的IDE或其他高级工具，更不用说在互联网上免费获得了。

与此同时，我们对使用当时所用语言及其相关构建系统来构建大型软件项目所需的过度复杂性感到沮丧。自从C、C++和Java等语言首次开发以来，计算机的速度已经快了无数倍，但编程行为本身却几乎没有取得同等程度的进步。此外，很明显多核处理器正在变得普及，但大多数语言在高效且安全地编程它们方面提供的帮助却很少。

我们决定退后一步，思考一下随着技术发展，未来几年哪些主要问题将主导软件工程，以及一种新语言如何帮助解决这些问题。例如，多核CPU的兴起表明，一种语言应该为某种形式的并发或并行提供一流的（first-class）支持。并且，为了在大型并发程序中使资源管理变得可行，垃圾回收，或至少某种安全的自动内存管理是必需的。

这些考虑因素引发了一系列讨论，最终催生了Go语言，最初是一系列想法和期望，然后发展成为一种语言。一个总括性的目标是，Go能通过启用工具化、自动化诸如代码格式化等繁琐任务以及消除在大型代码库上工作时的障碍，来为工作中的程序员提供更多帮助。

一篇更详尽的描述，阐述了Go的目标以及这些目标是如何被满足（或至少被接近）的，可以在文章《Go at Google：服务于软件工程的语言设计》中找到。

**这个项目的历史是什么？**

2007年9月21日，Robert Griesemer、Rob Pike和Ken Thompson开始在白板上勾勒新语言的目标。几天之内，目标就明确为一个行动计划，以及对它会是什么样子有了一个大致的构想。设计工作在与无关工作并行的情况下进行。到2008年1月，Ken已经开始着手编写一个编译器来探索这些想法；它生成的输出是C代码。到年中，这门语言已成为一个全职项目，并已足够成熟，可以尝试制作一个生产级编译器。2008年5月，Ian Taylor独立地开始基于草案规范为Go编写GCC前端。Russ Cox在2008年底加入，并帮助将语言和库从原型变为现实。

Go于2009年11月10日成为公开的开源项目。来自社区的无数人为此贡献了想法、讨论和代码。

如今，全球已有数百万Go程序员——“gophers”，并且每天都在增加。Go的成功远远超出了我们的预期。

**吉祥物“gopher”（土拨鼠）的来源是什么？**

吉祥物和标志由Renée French设计，她还设计了Plan 9的吉祥物“Glenda”（兔子）。一篇博客文章解释了这个gopher是如何从她几年前为WFMU设计的T恤图案演变而来的。该标志和吉祥物受知识共享署名4.0许可协议（Creative Commons Attribution 4.0 license）保护。

这个gopher有一个模型表（model sheet），说明了他的特征以及如何正确地描绘他。该模型表最初在2016年Renée在Gophercon大会上的一次演讲中展示。他有独特的特征；他是Go的gopher，而不仅仅是一般的土拨鼠。

**这门语言是叫Go还是Golang？**

这门语言叫Go。“golang”这个名称的出现是因为网站最初是golang.org。（当时还没有.dev域名。）尽管许多人使用golang这个名字，但它作为一个标签很方便。例如，这门语言在社交媒体上的标签是“#golang”。这门语言的名字就是简单的Go，不管怎样。

附注：尽管官方标志有两个大写字母，但语言名称应写作Go，而不是GO。

**你们为什么要创建一门新语言？**

Go诞生于我们对在Google工作时所使用的现有语言和环境的沮丧。编程变得过于困难，而语言的选择是部分原因。程序员们不得不在高效的编译、高效的执行和编程的便捷性之间做出选择；而这三者在同一种主流语言中是无法兼得的。那些有能力的程序员为了追求便捷，宁愿放弃安全性和效率，转而选择Python和JavaScript等动态类型语言，而不是C++或（在较小程度上）Java。

我们对这些问题的担忧并非孤例。在编程语言领域沉寂多年后，Go是首批出现的几种新语言之一——其他语言还包括Rust、Elixir、Swift等——它们再次让编程语言的开发成为一个活跃的、几乎是主流的领域。

Go试图通过将解释型动态类型语言的编程便捷性与静态类型编译语言的效率和安全性结合起来，来解决这些问题。它还旨在更好地适应当前的硬件，支持网络化和多核计算。最后，使用Go进行开发应该是快速的：在单台计算机上构建一个大型可执行文件最多只需几秒钟。为了实现这些目标，我们不得不重新思考当前语言中的一些编程方法，从而导致了：一种组合式而非分层式的类型系统；对并发和垃圾回收的支持；对依赖关系的严格规范；等等。这些特性无法很好地通过库或工具来处理，因此需要一门新的语言。

文章《Go at Google》讨论了Go语言设计的背景和动机，并提供了本FAQ中许多答案的更多细节。

**Go的祖先是什么？**

Go主要属于C语言家族（基本语法），并从Pascal/Modula/Oberon家族（声明、包）中借鉴了重要思想，同时还吸收了一些受Tony Hoare的CSP（通信顺序进程）启发的语言（如Newsqueak和Limbo）的思路（并发）。然而，它在各个方面都是一门全新的语言。在设计时，我们始终在思考程序员的实际工作，并致力于让编程——至少是我们所做的编程——变得更加高效，这意味着编程过程会更加有趣。

**设计的指导原则是什么？**

当设计Go时，Java和C++是编写服务器最常用的语言，至少在Google是如此。我们认为这些语言需要太多的簿记和重复。一些程序员因此转向了更动态、更灵活的语言，如Python，但代价是牺牲了效率和类型安全。我们认为，应该有可能在一种语言中同时拥有效率、安全性和灵活性。

Go试图减少“打字”（typing）的负担，无论是指键盘输入还是类型声明。在设计的方方面面，我们都努力减少杂乱和复杂性。没有前向声明，也没有头文件；所有内容都只需声明一次。初始化是富有表现力、自动且易于使用的。语法简洁，关键字很少。通过使用 `:=` 声明并初始化构造，减少了重复（例如 `foo.Foo* myFoo = new(foo.Foo)`）。也许最激进的是，没有类型层次结构：类型就是它们本身，它们不需要宣布它们之间的关系。这些简化使得Go既富有表现力又易于理解，而不会牺牲生产力。

另一个重要的原则是保持概念的正交性。任何类型都可以实现方法；结构体代表数据，而接口代表抽象；等等。正交性使得理解事物组合时会发生什么变得更加容易。

#### 用法

**Google在内部使用Go吗？**

是的。Go在Google内部被广泛用于生产环境。一个例子是Google的下载服务器dl.google.com，它负责分发Chrome二进制文件和其他大型安装包，如apt-get包。

Go远非Google使用的唯一语言，但它在包括站点可靠性工程（SRE）和大规模数据处理在内的多个领域都是一种关键语言。它也是运行Google Cloud的软件的关键组成部分。

**还有哪些公司在使用Go？**

Go的使用正在全球范围内增长，尤其是在云计算领域，但也绝不仅限于此。一些用Go编写的主要云基础设施项目有Docker和Kubernetes，但还有很多其他项目。

不仅仅是云计算，您可以在go.dev网站上的公司列表以及一些成功案例中看到这一点。此外，Go Wiki也包含一个页面，定期更新，列出了一些使用Go的公司。

Wiki还有一篇页面，链接了更多关于使用该语言的公司和项目的成功故事。

**Go程序可以与C/C++程序链接吗？**

有可能在同一个地址空间内同时使用C和Go，但这并非自然契合，可能需要特殊的接口软件。此外，将C与Go代码链接会放弃Go提供的内存安全和栈管理特性。有时为了解决问题，绝对有必要使用C库，但这样做总是会引入纯Go代码所没有的风险元素，因此请谨慎操作。

如果您确实需要在Go中使用C，那么如何操作取决于Go编译器的实现。由Google Go团队支持的Go工具链中的“标准”编译器称为 `gc`。此外，还有基于GCC的编译器（gccgo）和基于LLVM的编译器（gollvm），以及一个服务于不同目的的、不断增长的非常规编译器列表，有时实现语言的子集，例如TinyGo。

`gc` 使用与C不同的调用约定和链接器，因此无法直接从C程序调用，反之亦然。`cgo` 程序提供了“外部函数接口”（foreign function interface）的机制，允许从Go代码安全地调用C库。SWIG将此功能扩展到了C++库。

您也可以将 `cgo` 和 SWIG 与 `gccgo` 和 `gollvm` 一起使用。由于它们使用传统的ABI，因此在非常小心的情况下，也可以将这些编译器生成的代码直接与GCC/LLVM编译的C或C++程序链接。然而，安全地做到这一点需要了解所涉及的所有语言的调用约定，并在从Go调用C或C++时关注栈限制。

**Go支持哪些IDE？**

Go项目本身不包含自定义的IDE，但语言和库的设计使得分析源代码变得很容易。因此，大多数知名的编辑器和IDE都对Go提供了良好的支持，无论是直接支持还是通过插件。

Go团队还支持一个用于LSP协议的Go语言服务器，名为 `gopls`。支持LSP的工具可以使用 `gopls` 来集成特定于语言的支持。

提供良好Go支持的知名IDE和编辑器列表包括Emacs、Vim、VSCode、Atom、Eclipse、Sublime、IntelliJ（通过一个名为GoLand的自定义变体）等等。很可能您最喜欢的开发环境也是编写Go代码的高效选择。

**Go支持Google的协议缓冲区（protocol buffers）吗？**

一个独立的开源项目提供了必要的编译器插件和库。它位于 github.com/golang/protobuf/。

#### 设计

**Go有运行时（runtime）吗？**

Go有一个庞大的运行时库，通常简称为“runtime”，它是每个Go程序的一部分。这个库实现了垃圾回收、并发、栈管理以及Go语言的其他关键特性。尽管它在语言中处于更核心的地位，但Go的运行时类似于C库（libc）。

然而，重要的是要理解，Go的运行时并不包含虚拟机，比如Java运行时提供的那种。Go程序在运行前被编译成原生机器代码（或对于某些变体实现，是JavaScript或WebAssembly）。因此，尽管“runtime”一词常用来描述程序运行的虚拟环境，但在Go中，“runtime”只是给提供关键语言服务的库所起的名字。

**关于Unicode标识符是怎么回事？**

在设计Go时，我们希望确保它不会过度以ASCII为中心，这意味着要将标识符的范围从7位ASCII的限制中扩展出去。Go的规则——标识符字符必须是Unicode定义的字母或数字——简单易懂且易于实现，但也有其限制。例如，组合字符被有意排除在外，这排除了某些语言，如天城文（Devanagari）。

这条规则还有另一个不幸的后果。由于导出的标识符必须以大写字母开头，因此根据定义，某些语言创建的标识符无法被导出。目前唯一的解决方案是使用类似 `X日本語` 这样的形式，这显然不令人满意。

自语言的最早版本以来，我们一直在深入思考如何最好地扩展标识符空间，以容纳使用其他母语的程序员。具体该怎么做仍然是一个活跃的讨论话题，未来版本的语言可能会在标识符的定义上更加宽松。例如，它可能会采用Unicode组织关于标识符建议中的一些想法。无论如何，都必须以兼容的方式进行，同时保留（或可能扩展）字母大小写决定标识符可见性的方式，这仍然是我们最喜欢的Go特性之一。

目前，我们有一条简单的规则，将来可以在不破坏程序的情况下进行扩展，这条规则避免了因允许模糊标识符而必然产生的bug。

**为什么Go没有特性X？**

每种语言都包含新颖的特性，也会缺少某人最喜欢的特性。Go的设计着眼于编程的流畅性、编译速度、概念的正交性，以及支持并发和垃圾回收等特性。您最喜欢的特性可能缺失，是因为它不符合设计，因为它会影响编译速度或设计的清晰度，或者因为它会使基础系统模型变得过于困难。

如果Go缺少特性X让您感到困扰，请原谅我们，并去了解一下Go所拥有的特性。您可能会发现，它们以有趣的方式弥补了X的缺失。

**Go是什么时候获得泛型类型的？**

Go 1.18版本向语言中添加了类型参数。这允许一种多态或泛型编程的形式。详情请参见语言规范和提案。

**Go最初发布时为什么没有泛型类型？**

Go旨在成为一种编写服务器程序的语言，这些程序需要易于长期维护。（更多背景信息请参见这篇文章。）设计的重点是可扩展性、可读性和并发性。多态编程在当时似乎对语言的目标并非至关重要，因此为了简洁起见，最初被省略了。

泛型很方便，但它们会以类型系统和运行时的复杂性为代价。我们花了一些时间才开发出一种我们认为其价值与复杂性相称的设计。

**为什么Go没有异常（exceptions）？**

我们认为，将异常与控制结构（如try-catch-finally惯用法）耦合在一起，会导致代码变得复杂。它也倾向于鼓励程序员将太多普通错误（例如无法打开文件）标记为异常情况。

Go采取了不同的方法。对于简单的错误处理，Go的多值返回使得报告错误变得容易，而无需重载返回值。一个标准的错误类型，加上Go的其他特性，使得错误处理变得愉快，但与其它语言大不相同。

Go还有几个内置函数，用于报告和从真正异常的情况中恢复。恢复机制仅在函数因错误而被拆除其状态时执行，这足以处理灾难性情况，但不需要额外的控制结构，并且如果使用得当，可以产生干净的错误处理代码。

详情请参见《Defer, Panic, and Recover》一文。此外，《Errors are values》这篇博客文章描述了一种在Go中干净处理错误的方法，通过演示错误就是值，因此可以使用Go的全部能力来处理错误。

**为什么Go没有断言（assertions）？**

Go不提供断言。它们无疑很方便，但我们的经验是，程序员会把它们当作拐杖，以避免思考适当的错误处理和报告。适当的错误处理意味着服务器在发生非致命错误后会继续运行，而不是崩溃。适当的错误报告意味着错误是直接且切中要点的，这让程序员无需解读冗长的崩溃追踪。当看到错误的程序员不熟悉代码时，精确的错误尤其重要。

我们理解这是一个有争议的点。Go语言和库中有许多东西与现代实践不同，只是因为我们觉得有时尝试一种不同的方法是值得的。

**为什么并发要基于CSP的思想构建？**

并发和多线程编程长期以来一直被认为很困难。我们认为这在一定程度上是由于像pthreads这样复杂的设计，以及在互斥锁、条件变量和内存屏障等低级细节上过度强调。更高级别的接口可以实现更简单的代码，即使底层仍然有互斥锁等机制。

为并发提供高级语言支持的最成功模型之一来自Hoare的“通信顺序进程”（Communicating Sequential Processes, CSP）。Occam和Erlang是两种源自CSP的著名语言。Go的并发原语源自家族树的另一分支，其主要贡献是将通道（channels）作为一流对象的强有力概念。与几种早期语言的经验表明，CSP模型非常适合融入过程式语言框架。

**为什么使用goroutine而不是线程？**

goroutine是让并发变得易于使用的一部分。这个想法已经存在了一段时间，其核心是将独立执行的函数（协程）多路复用到一组线程上。当一个协程阻塞时（例如调用一个阻塞的系统调用），运行时会自动将同一个操作系统线程上的其他协程移动到另一个可运行的线程上，这样它们就不会被阻塞。程序员看不到这些细节，而这正是关键所在。结果，我们称之为goroutine，它们可以非常轻量：除了栈的内存开销外，几乎没有其他开销，而栈通常只有几千字节。

为了使栈变小，Go的运行时使用可调整大小、有界（bounded）的栈。一个新创建的goroutine会被赋予几千字节的空间，这几乎总是足够的。当不够时，运行时会自动增长（和缩小）栈的内存，允许多个goroutine在有限的内存中生存。CPU开销平均每个函数调用大约三到四条廉价的指令。在同一个地址空间中创建数十万个goroutine是切实可行的。如果goroutine只是线程，系统资源会在小得多的数量级上耗尽。

**为什么map操作没有定义为原子的？**

经过长时间的讨论，我们决定map的典型用法并不需要从多个goroutine进行安全访问，而在那些确实需要的情况下，map很可能是某个已经同步的更大数据结构或计算的一部分。因此，要求所有map操作都获取互斥锁会拖慢大多数程序，却只给少数程序增加安全性。然而，这并不是一个容易的决定，因为它意味着不受控制的map访问可能会导致程序崩溃。

语言本身并不排除原子的map更新。在需要时，例如在托管不受信任的程序时，实现可以对map访问进行互锁。

只有在发生更新时，map访问才是不安全的。只要所有goroutine都只读取（在map中查找元素，包括使用for range循环遍历它），而不通过赋值或删除来改变map，那么它们就可以在没有同步的情况下安全地并发访问map。

作为正确使用map的辅助手段，该语言的一些实现包含一个特殊检查，可以在运行时自动报告当map被并发执行不安全修改时的情况。此外，sync库中有一个名为 `sync.Map` 的类型，对于静态缓存等特定使用模式效果很好，尽管它不适合完全替代内置的map类型。

**你们会接受我的语言修改吗？**

人们经常建议对语言进行改进——邮件列表中充满了此类讨论的丰富历史——但这些修改中很少有被接受的。

尽管Go是一个开源项目，但语言和库受到一个兼容性承诺的保护，该承诺阻止了会破坏现有程序的更改，至少在源代码级别上是如此（程序可能需要偶尔重新编译以保持最新）。如果您的提议违反了Go 1规范，我们甚至无法考虑这个想法，无论其优点如何。未来的Go主要版本可能与Go 1不兼容，但关于该主题的讨论才刚刚开始，有一件事是确定的：在此过程中引入的不兼容性将非常少。此外，兼容性承诺鼓励我们为旧程序提供自动的升级路径，以防这种情况发生。

即使您的提议与Go 1规范兼容，它也可能不符合Go的设计目标。文章《Go at Google: Language Design in the Service of Software Engineering》解释了Go的起源和其设计背后的动机。

#### 类型

**Go是面向对象的语言吗？**

是也不是。虽然Go有类型和方法，并允许面向对象的编程风格，但它没有类型层次结构。Go中的“接口”（interface）概念提供了一种不同的方法，我们认为它更易于使用，并在某些方面更具通用性。还有方法可以将类型嵌入到其他类型中，以提供类似于（但不完全等同于）子类化的东西。此外，Go中的方法比C++或Java中的更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的“未装箱”整数。它们不限于结构体（类）。

此外，缺乏类型层次结构使得Go中的“对象”感觉比C++或Java等语言中的要轻量得多。

**如何实现方法的动态分派？**

实现动态分派方法的唯一方法是通过接口。结构体或任何其他具体类型上的方法总是静态解析的。

**为什么没有类型继承？**

面向对象编程，至少在最知名的那些语言中，涉及太多关于类型之间关系的讨论，而这些关系往往是可以自动推导的。Go采取了不同的方法。

Go不要求程序员提前声明两种类型是相关的，而是让一个类型自动满足任何指定了其方法子集的接口。除了减少簿记工作外，这种方法还有真正的优势。一个类型可以同时满足多个接口，而无需传统多重继承的复杂性。接口可以非常轻量——一个带有一个甚至零个方法的接口就能表达一个有用的概念。接口可以在事后添加，无论是因为出现了新想法还是为了测试——而无需注解原始类型。因为类型和接口之间没有显式的关系，所以没有类型层次结构需要管理和讨论。

有可能利用这些思想来构建类似于类型安全的Unix管道的东西。例如，看看`fmt.Fprintf`如何实现将格式化输出打印到任何输出，而不仅仅是文件，或者`bufio`包如何能完全独立于文件I/O，或者`image`包如何生成压缩的图像文件。所有这些思想都源于一个单一的接口（`io.Writer`），它代表了一个单一的方法（`Write`）。而这仅仅是冰山一角。Go的接口深刻地影响了程序的结构方式。

这种隐式的类型依赖风格需要一些时间来适应，但这是Go最富有成效的特性之一。

**为什么len是函数而不是方法？**

我们讨论过这个问题，但最终决定将len及其类似函数实现为函数在实践中是可行的，并且不会使基本类型的接口（在Go类型意义上）问题复杂化。

**为什么Go不支持方法和运算符的重载？**

如果方法分派不需要进行类型匹配，那么它就会简化。其他语言的经验告诉我们，拥有大量同名但签名不同的方法偶尔有用，但在实践中也可能造成混淆和脆弱。只按名称匹配并要求类型一致，是Go类型系统中的一个重大简化决策。

至于运算符重载，它似乎更多是一种便利，而非绝对必需。同样，没有它，事情会更简单。

**为什么Go没有“implements”声明？**

Go类型通过实现接口的方法来实现一个接口，仅此而已。这一特性允许在无需修改现有代码的情况下定义和使用接口。它实现了一种结构化类型，促进了关注点分离，提高了代码重用性，并使得在代码发展过程中更容易构建出现的模式。接口的语义是Go语言感觉灵活、轻量的主要原因之一。

更多细节请参见关于类型继承的问题。

**如何保证我的类型满足某个接口？**

您可以通过尝试使用T或指向T的零值（视情况而定）进行赋值，来让编译器检查类型T是否实现了接口I：

```go
type T struct{}
var _ I = T{}       // 验证T实现了I。
var _ I = (*T)(nil) // 验证*T实现了I。
```

如果T（或相应的*T）没有实现I，这个错误会在编译时被捕获。

如果您希望接口的使用者明确声明他们实现了该接口，您可以在接口的方法集中添加一个带有描述性名称的方法。例如：

```go
type Fooer interface {
    Foo()
    ImplementsFooer()
}
```

那么一个类型必须实现`ImplementsFooer`方法才能成为`Fooer`，这清楚地记录了事实，并在`go doc`的输出中宣布了这一点。

```go
type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
```

大多数代码不使用这种约束，因为它们限制了接口思想的实用性。然而，有时它们对于解决类似接口之间的歧义是必要的。

**为什么类型T不满足Equal接口？**

考虑这个简单的接口，用于表示一个可以与另一个值比较的对象：

```go
type Equaler interface {
    Equal(Equaler) bool
}
```

以及这个类型T：

```go
type T int
func (t T) Equal(u T) bool { return t == u } // 不满足Equaler
```

与某些多态类型系统中的类似情况不同，T不实现Equaler。T.Equal的参数类型是T，而不是接口所要求的Equaler类型。

在Go中，类型系统不会提升Equal的参数；这是程序员的责任，如下所示的类型T2，它确实实现了Equaler：

```go
type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // 满足Equaler
```

尽管如此，这与其它类型系统也不同，因为在Go中，任何满足Equaler的类型都可以作为参数传递给T2.Equal，在运行时我们必须检查该参数是否为T2类型。有些语言会在编译时安排好这种保证。

一个相关的例子则相反：

```go
type Opener interface {
   Open() Reader
}
func (t T3) Open() *os.File
```

在Go中，T3不满足Opener，尽管在另一种语言中它可能会。

虽然在这些情况下，Go的类型系统确实为程序员做的事情更少，但缺乏子类型使得关于接口满足的规则非常容易表述：函数的名称和签名是否与接口完全一致？Go的规则也易于高效实现。我们认为这些好处抵消了自动类型提升的缺失。

**我能直接将 `[]T` 转换为 `[]interface{}` 吗？**

不能直接转换。语言规范禁止这样做，因为这两种类型在内存中的表示不同。必须将元素逐个复制到目标切片中。此示例将一个int切片转换为一个`interface{}`切片：

```go
t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v
}
```

**如果T1和T2有相同的底层类型，我能将 `[]T1` 转换为 `[]T2` 吗？**

此代码示例的最后一行无法编译。

```go
type T1 int
type T2 int
var t1 T1
var x = T2(t1) // OK
var st1 []T1
var sx = ([]T2)(st1) // NOT OK
```

在Go中，类型与方法紧密相关，因为每个命名类型都有一个（可能为空的）方法集。一般规则是，您可以更改被转换类型的名称（从而可能更改其方法集），但不能更改复合类型元素的名称（和方法集）。Go要求您在类型转换上明确说明。

**为什么我的nil错误值不等于nil？**

在底层，接口是用两个元素实现的：一个类型T和一个值V。V是一个具体的值，比如int、struct或指针，永远不会是接口本身，其类型为T。例如，如果我们把int值3存储在一个接口中，结果接口值在结构上具有(T=int, V=3)。值V也被称为接口的动态值，因为一个给定的接口变量在程序执行过程中可能持有不同的值V（和相应的类型T）。

只有当V和T都未设置时，一个接口值才是nil，即(T=nil, V未设置)。特别是，一个nil接口将始终持有一个nil类型。如果我们把一个类型为`*int`的nil指针存储在一个接口值中，内部类型将始终是`*int`，无论指针的值如何：(T=`*int`, V=nil)。因此，这样的接口值即使内部的指针值V是nil，也不会是nil。

这种情况可能令人困惑，并且会在将nil值存储在接口值中（如错误返回）时出现：

```go
func returnsError() error {
    var p *MyError = nil
    if bad() {
        p = ErrBad
    }
    return p // 将始终返回一个非nil的错误。
}
```

如果一切顺利，该函数返回一个nil的p，因此返回值是一个持有(T=`*MyError`, V=nil)的错误接口值。这意味着如果调用者将返回的错误与nil进行比较，即使没有发生任何坏事，它看起来也总是像有错误一样。为了向调用者返回一个正确的nil错误，该函数必须返回一个显式的nil：

```go
func returnsError() error {
    if bad() {
        return ErrBad
    }
    return nil
}
```

建议返回错误的函数在签名中始终使用error类型（如上所示），而不是`*MyError`这样的具体类型，以帮助确保错误被正确创建。例如，`os.Open`返回一个错误，即使它不为nil，其具体类型也总是`*os.PathError`。

每当使用接口时，都可能出现与上述描述类似的情况。只要记住，如果任何具体值已存储在接口中，该接口就不会是nil。欲了解更多信息，请参见《The Laws of Reflection》。

**为什么零大小的类型行为奇怪？**

Go支持零大小的类型，例如没有字段的结构体（`struct{}`）或没有元素的数组（`[0]byte`）。您无法在零大小的类型中存储任何值，但当不需要值时，这些类型有时很有用，例如在`map[int]struct{}`中，或一个有方法但没有值的类型。

具有零大小类型的**不同**变量可能会被放置在内存中的同一位置。这是安全的，因为无法在这些变量中存储任何值。

此外，语言不保证指向两个不同零大小变量的指针是否会相等。这样的比较甚至可能在程序的某个时刻返回true，而在另一个时刻返回false，这取决于程序被编译和执行的具体方式。

零大小类型的另一个问题是，指向零大小结构体字段的指针不能与指向内存中不同对象的指针重叠。这可能会导致垃圾回收器混淆。这意味着，如果结构体的最后一个字段是零大小的，该结构体会被填充，以确保指向最后一个字段的指针不会与紧跟在结构体之后的内存重叠。因此，此程序：

```go
func main() {
    type S struct {
        f1 byte
        f2 struct{}
    }
    fmt.Println(unsafe.Sizeof(S{}))
}
```

在大多数Go实现中会打印2，而不是1。

**为什么没有像C语言那样的无标签联合（untagged unions）？**

无标签联合会违反Go的内存安全保证。

**为什么Go没有变体类型？**

变体类型，也称为代数类型，提供了一种指定一个值可能是其他一组类型之一（但仅限于这些类型）的方法。在系统编程中的一个常见例子是，指定一个错误是网络错误、安全错误或应用程序错误，并允许调用者通过检查错误的类型来区分问题的来源。另一个例子是语法树，其中每个节点可以是不同的类型：声明、语句、赋值等等。

我们曾考虑将变体类型添加到Go中，但经过讨论后决定将其排除，因为它们与接口以令人困惑的方式重叠。如果变体类型的元素本身是接口，会发生什么？

此外，变体类型解决的一些问题已经被语言所覆盖。使用接口值来持有错误并通过类型开关（type switch）来区分情况，可以很容易地表达错误示例。语法树示例也可以实现，尽管没有那么优雅。

**为什么Go没有协变返回类型？**

协变返回类型意味着像

```go
type Copyable interface {
    Copy() interface{}
}
```

这样的接口会被方法

```go
func (v Value) Copy() Value
```

所满足，因为Value实现了空接口。在Go中，方法类型必须完全匹配，因此Value不实现Copyable。Go将一个类型做什么（它的方法）与其类型的实现分离开来。如果两个方法返回不同的类型，它们就不是在做同一件事。想要协变返回类型的程序员通常试图通过接口来表达类型层次结构。在Go中，接口和实现之间的清晰分离更为自然。

#### 值

**为什么Go不提供隐式的数值转换？**

C语言中自动在数值类型间转换的便利性，被它带来的困惑所抵消。一个表达式什么时候是无符号的？它的值有多大？它会溢出吗？结果是否可移植，独立于其执行的机器？它也使编译器复杂化；C的“通常算术转换”（usual arithmetic conversions）不容易实现，并且在不同架构上不一致。出于可移植性的原因，我们决定让事情变得清晰和直接，以代码中一些显式转换为代价。Go中常量的定义——不受符号和大小注解限制的任意精度值——在很大程度上缓解了这个问题。

一个相关的细节是，与C语言不同，即使int是64位类型，int和int64也是不同的类型。int类型是通用的；如果您关心整数有多少位，Go鼓励您明确说明。

**Go中的常量是如何工作的？**

尽管Go对不同数值类型变量之间的转换很严格，但语言中的常量要灵活得多。字面常量如23、3.14159和math.Pi占据着一种理想的数字空间，具有任意精度，不会溢出或下溢。例如，math.Pi的值在源代码中指定了63位小数，涉及该值的常量表达式保持的精度超出了float64所能容纳的范围。只有当常量或常量表达式被赋值给一个变量——程序中的一个内存位置时——它才变成一个具有通常浮点特性和精度的“计算机”数字。

此外，因为它们只是数字，而不是有类型的值，Go中的常量可以比变量更自由地使用，从而减轻了一些严格转换规则带来的尴尬。可以写出像

```go
sqrt2 := math.Sqrt(2)
```

这样的表达式，而不会受到编译器的抱怨，因为理想的数字2可以安全、准确地转换为float64以供调用math.Sqrt。

一篇名为《Constants》的博客文章更详细地探讨了这个主题。

**为什么map是内置的？**

原因和字符串一样：它们是如此强大和重要的数据结构，提供一个优秀的实现并给予语法支持，能让编程更愉快。我们相信Go的map实现足够强大，可以满足绝大多数用途。如果某个特定应用能从自定义实现中受益，可以编写一个，但它在语法上不会那么方便；这似乎是一个合理的权衡。

**为什么map不允许slice作为键？**

map查找需要一个相等运算符，而slice没有实现。它们不实现相等性，是因为对于这类类型，相等性没有明确定义；涉及浅比较与深比较、指针比较与值比较、如何处理递归类型等多个考虑因素。我们可能会重新审视这个问题——实现slice的相等性不会使任何现有程序失效——但在对slice相等性应该意味着什么没有清晰想法的情况下，现在将其省略更简单。

结构体和数组定义了相等性，因此它们可以用作map的键。

**为什么map、slice和channel是引用，而数组是值？**

这个问题有很多历史。早期，map和channel在语法上是指针，不可能声明或使用一个非指针实例。同时，我们也为数组应该如何工作而挣扎。最终我们决定，指针和值的严格分离使语言更难使用。将这些类型改为作为相关共享数据结构的引用，解决了这些问题。这种改变给语言增加了一些遗憾的复杂性，但对可用性产生了巨大影响：当它被引入时，Go变成了一种更高效、更舒适的语言。

#### 编写代码

**如何为库编写文档？**

要从命令行访问文档，`go`工具有一个`doc`子命令，它为声明、文件、包等提供文本接口的文档。

全局包发现页面 pkg.go.dev/pkg/ 运行一个服务器，从网络上任何地方的Go源代码中提取包文档，并以带有指向声明和相关元素链接的HTML形式提供服务。这是了解现有Go库的最简单方法。

在项目早期，有一个类似的程序叫`godoc`，它可以运行来提取本地机器上文件的文档；pkg.go.dev/pkg/ 本质上是它的后继者。另一个后继者是`pkgsite`命令，它和`godoc`一样可以在本地运行，尽管它尚未集成到`go doc`显示的结果中。

**有Go编程风格指南吗？**

没有明确的风格指南，尽管确实存在一种可识别的“Go风格”。

Go建立了一些约定来指导命名、布局和文件组织方面的决策。文档《Effective Go》包含了一些关于这些主题的建议。更直接的是，`gofmt`程序是一个格式化工具，其目的是强制执行布局规则；它取代了通常的“该做”和“不该做”的清单，这些清单允许解释。仓库中的所有Go代码以及开源世界中的绝大多数代码都经过了`gofmt`处理。

名为《Go Code Review Comments》的文档是一系列关于Go惯用法细节的非常简短的散文，这些细节经常被程序员忽略。它是人们为Go项目进行代码审查时的便捷参考。

**如何向Go库提交补丁？**

库的源代码位于仓库的src目录中。如果您想进行重大更改，请在开始之前先在邮件列表上讨论。

更多信息请参见《为Go项目做贡献》文档。

**为什么“go get”在克隆仓库时使用HTTPS？**

公司通常只允许在标准的TCP端口80（HTTP）和443（HTTPS）上进行出站流量，阻止在其他端口（包括TCP端口9418（git）和TCP端口22（SSH））上的出站流量。当使用HTTPS而不是HTTP时，git默认强制执行证书验证，提供对中间人攻击、窃听和篡改的保护。“go get”命令因此为了安全而使用HTTPS。

可以配置git通过HTTPS进行身份验证，或使用SSH代替HTTPS。要通过HTTPS进行身份验证，可以在git查询的`$HOME/.netrc`文件中添加一行：

```
machine github.com login *USERNAME* password *APIKEY*
```

对于GitHub账户，密码可以是个人访问令牌。

也可以配置git，对于匹配给定前缀的URL，使用SSH代替HTTPS。例如，要对所有GitHub访问使用SSH，请将以下行添加到您的`~/.gitconfig`中：

```
[url "ssh://git@github.com/"]
    insteadOf = https://github.com/
```

在使用私有模块但使用公共模块代理来处理依赖项时，您可能需要设置GOPRIVATE。详情请参见私有模块和附加设置。

**如何使用“go get”管理包版本？**

Go工具链有一个内置的系统，用于管理一组相关的、有版本的包，称为模块（modules）。模块在Go 1.11中引入，自1.14以来已准备好用于生产环境。

要创建一个使用模块的项目，请运行`go mod init`。此命令创建一个`go.mod`文件来跟踪依赖版本。

```bash
go mod init example/project
```

要添加、升级或降级依赖项，请运行`go get`：

```bash
go get golang.org/x/text@v0.3.5
```

更多信息请参见教程：创建一个模块。

请参阅开发模块，了解使用模块管理依赖关系的指南。

模块内的包在演变时应保持向后兼容，遵循导入兼容性规则：

如果一个旧包和一个新包具有相同的导入路径，
那么新包必须与旧包向后兼容。

Go 1兼容性指南是一个很好的参考：不要删除导出的名称，鼓励使用带标签的复合字面量，等等。如果需要不同的功能，请添加一个新名称，而不是更改旧名称。

模块通过语义化版本控制（semantic versioning）和语义化导入版本控制（semantic import versioning）来规范这一点。如果需要破坏兼容性，请在新的主版本上发布一个模块。主版本2及以上的模块需要在路径中包含主版本后缀（如`/v2`）。这保留了导入兼容性规则：模块不同主版本中的包具有不同的路径。

#### 指针和分配

**函数参数何时按值传递？**

和C语言家族的所有语言一样，Go中的一切都是按值传递的。也就是说，函数总是得到被传递事物的一个副本，就像有一条赋值语句将该值赋给参数一样。例如，向一个函数传递一个int值会复制该int，而传递一个指针值会复制该指针，但不会复制它指向的数据。（关于这对方法接收者的影响，请参见后面的章节。）

map和slice值的行为类似于指针：它们是包含指向底层map或slice数据的指针的描述符。复制一个map或slice值不会复制它所指向的数据。复制一个接口值会复制存储在该接口值中的东西。如果接口值包含一个结构体，则复制该接口值会复制该结构体。如果接口值包含一个指针，则复制该接口值会复制该指针，但同样不会复制它指向的数据。

请注意，这里的讨论是关于操作的语义。实际的实现可能会应用优化来避免复制，只要这些优化不改变语义。

**我什么时候应该使用指向接口的指针？**

几乎从不。指向接口值的指针只出现在少数罕见、棘手的情况下，涉及为了延迟求值而伪装接口值的类型。

一个常见的错误是将指向接口值的指针传递给期望接口的函数。编译器会抱怨这个错误，但这种情况仍然可能令人困惑，因为有时需要指针才能满足接口。关键在于，尽管指向具体类型的指针可以满足接口，但有一个例外，指向接口的指针永远无法满足接口。

考虑变量声明，

```go
var w io.Writer
```

打印函数`fmt.Fprintf`将其第一个参数作为满足`io.Writer`的值——即实现标准`Write`方法的东西。因此我们可以写

```go
fmt.Fprintf(w, "hello, world\n")
```

然而，如果我们传递w的地址，程序将无法编译。

```go
fmt.Fprintf(&w, "hello, world\n") // 编译时错误。
```

唯一的例外是，任何值，甚至是指向接口的指针，都可以赋给空接口类型（`interface{}`）的变量。即便如此，如果该值是指向接口的指针，那几乎肯定是个错误；结果可能会令人困惑。

**我应该在值还是指针上定义方法？**

```go
func (s *MyStruct) pointerMethod() { } // 指针上的方法
func (s MyStruct)  valueMethod()   { } // 值上的方法
```

对于不习惯指针的程序员来说，这两个例子之间的区别可能会令人困惑，但情况实际上非常简单。当在类型上定义方法时，接收者（上面例子中的s）的行为与它作为方法的参数完全一样。因此，是将接收者定义为值还是指针，与函数参数应该是值还是指针是同一个问题。有几个考虑因素。

首先，也是最重要的，方法是否需要修改接收者？如果需要，接收者必须是指针。（切片和map的行为像引用，所以它们的情况稍微微妙一些，但例如，要在方法中改变切片的长度，接收者仍然必须是指针。）在上面的例子中，如果`pointerMethod`修改了s的字段，调用者会看到这些更改，但`valueMethod`是用调用者参数的副本调用的（这就是按值传递的定义），因此它所做的更改对调用者是不可见的。

顺便说一下，在Java中，方法接收者始终是指针，尽管它们的指针性质有些被掩盖了（最近的发展正将值接收者引入Java）。Go中不寻常的是值接收者。

第二个考虑是效率。如果接收者很大，比如一个大的结构体，使用指针接收者可能更便宜。

接下来是**一致性**。如果该类型的一些方法必须使用指针接收者，其余的也应该使用，这样无论类型如何使用，方法集都是一致的。详情请参见关于方法集的部分。

对于基本类型、切片和小型结构体等类型，值接收者非常便宜，因此除非方法的语义需要指针，否则值接收者是高效且清晰的。

**new和make有什么区别？**

简而言之：`new`分配内存，而`make`初始化切片、map和channel类型。

更多细节请参见《Effective Go》中的相关章节。

**64位机器上int的大小是多少？**

int和uint的大小是实现相关的，但在给定平台上两者大小相同。为了可移植性，依赖特定值大小的代码应使用显式指定大小的类型，如int64。在32位机器上，编译器默认使用32位整数，而在64位机器上，整数是64位的。（历史上，情况并非总是如此。）

另一方面，浮点标量和复数类型总是有明确大小的（没有float或complex基本类型），因为程序员在使用浮点数时应该意识到精度问题。未类型化浮点常量的默认类型是float64。因此`foo := 3.0`声明了一个类型为float64的变量foo。对于由（未类型化）常量初始化的float32变量，必须在变量声明中明确指定变量类型：

```go
var foo float32 = 3.0
```

或者，常量必须通过转换来赋予类型，如`foo := float32(3.0)`。

**我如何知道一个变量是分配在堆上还是栈上？**

从正确性的角度来看，你不需要知道。Go中的每个变量只要还有对它的引用就会存在。实现选择的存储位置与语言的语义无关。

存储位置确实会影响编写高效程序。只要可能，Go编译器会将函数的局部变量分配在该函数的栈帧中。然而，如果编译器无法证明该变量在函数返回后不再被引用，那么编译器必须将该变量分配在垃圾回收的堆上，以避免悬空指针错误。此外，如果一个局部变量非常大，将其存储在堆上而不是栈上可能更有意义。

在当前的编译器中，如果一个变量的地址被获取了，那么该变量就有资格在堆上分配。然而，基本的逃逸分析（escape analysis）会识别出一些情况，即这样的变量在函数返回后不会存活，可以驻留在栈上。

**为什么我的Go进程使用了这么多虚拟内存？**

Go内存分配器为分配保留了一个大的虚拟内存区域，作为一个“竞技场”（arena）。这个虚拟内存是特定于Go进程的；这种保留不会剥夺其他进程的内存。

要查找分配给Go进程的实际内存量，请使用Unix top命令并查看RES（Linux）或RSIZE（macOS）列。

#### 并发

**哪些操作是原子的？关于互斥锁呢？**

Go中操作的原子性描述可以在《Go内存模型》文档中找到。

低级别的同步和原子原语在`sync`和`sync/atomic`包中可用。这些包适用于简单的任务，如递增引用计数或保证小范围的互斥。

对于更高级别的操作，如协调并发服务器，更高级的技术可以带来更好的程序，Go通过其goroutine和channel支持这种方法。例如，您可以这样组织您的程序：在任何时刻，只有一个goroutine负责特定的数据。这种方法总结了最初的Go格言：

**不要通过共享内存来通信，而是通过通信来共享内存。**

请参阅《通过通信共享内存》的代码走读及其相关文章，以详细了解这个概念。

大型并发程序可能会从这两个工具包中都借用。

**为什么我的程序在使用更多CPU时没有运行得更快？**

一个程序在使用更多CPU时是否运行得更快，取决于它所解决的问题。Go语言提供了并发原语，如goroutine和channel，但并发只有在底层问题本质上是并行的时候才能实现并行化。本质上是顺序的问题无法通过增加更多CPU来加速，而那些可以分解成可以并行执行的片段的问题则可以加速，有时是显著加速。

有时增加更多CPU会减慢程序速度。在实际应用中，花费更多时间进行同步或通信而不是进行有用计算的程序，在使用多个操作系统线程时可能会遇到性能下降。这是因为在线程间传递数据涉及上下文切换，这有显著的成本，并且随着CPU的增加，这种成本可能会增加。例如，Go规范中的质数筛子（prime sieve）示例没有显著的并行性，尽管它启动了许多goroutine；增加线程（CPU）的数量更有可能减慢它而不是加速它。

有关此主题的更多详细信息，请参见题为《并发不是并行》的演讲。

**如何控制CPU的数量？**

同时执行的goroutine可用的CPU数量由GOMAXPROCS shell环境变量控制，其默认值是可用的CPU核心数。因此，具有并行执行潜力的程序在多CPU机器上默认应能实现并行。要更改要使用的并行CPU数量，请设置环境变量，或使用runtime包中同名的函数来配置运行时支持，以利用不同数量的线程。将其设置为1会消除真正的并行性可能，强制独立的goroutine轮流执行。

运行时可以分配比GOMAXPROCS更多的线程来服务多个未完成的I/O请求。GOMAXPROCS只影响可以同时实际执行的goroutine数量；任意数量的goroutine可能阻塞在系统调用中。

Go的goroutine调度器在平衡goroutine和线程方面做得很好，甚至可以抢占goroutine的执行，以确保同一线程上的其他goroutine不会被饿死。然而，它并不完美。如果您看到性能问题，按每个应用程序设置GOMAXPROCS可能会有所帮助。

**为什么没有goroutine ID？**

goroutine没有名字；它们只是匿名的工作者。它们不向程序员暴露任何唯一的标识符、名称或数据结构。有些人对此感到惊讶，期望`go`语句返回一个可以用来以后访问和控制goroutine的项。

goroutine是匿名的根本原因，是为了在编写并发代码时可以使用完整的Go语言。相比之下，当线程和goroutine被命名时形成的使用模式，可能会限制使用它们的库所能做的事情。

这里有一个说明困难的例子。一旦人们命名了一个goroutine并围绕它构建了一个模型，它就变得特殊了，人们会倾向于将所有计算都与那个goroutine关联起来，忽略了使用多个可能共享的goroutine进行处理的可能性。如果`net/http`包将每个请求的状态与一个goroutine关联起来，客户端在服务请求时就无法使用更多的goroutine。

此外，使用要求所有处理都必须在“主线程”上发生的库（如某些图形系统库）的经验表明，当在并发语言中部署时，这种方法有多么笨拙和受限。特殊线程或goroutine的存在本身就会迫使程序员扭曲程序，以避免在错误的线程上操作时发生崩溃和其他问题。

对于那些真正特殊goroutine的情况，语言提供了通道（channels）等特性，可以灵活地与之交互。

#### 函数和方法

**为什么T和*T有不同的方法集？**

正如Go规范所说，类型T的方法集包含所有接收者类型为T的方法，而相应指针类型`*T`的方法集包含所有接收者为`*T`或T的方法。这意味着`*T`的方法集包含了T的方法集，但反过来则不成立。

这种区别产生是因为，如果一个接口值包含一个指针`*T`，方法调用可以通过解引用指针来获得一个值，但如果一个接口值包含一个值T，则没有安全的方法让方法调用获得一个指针。（这样做将允许一个方法修改接口内值的内容，而这是语言规范所不允许的。）

即使在编译器可以取值的地址来传递给方法的情况下，如果该方法修改了值，这些更改在调用者中也会丢失。

举个例子，如果下面的代码是有效的：

```go
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
```

它会将标准输入复制到buf的一个副本中，而不是buf本身。这几乎从来不是期望的行为，因此被语言禁止。

**作为goroutine运行的闭包会发生什么？**

由于循环变量的工作方式，在Go 1.22版本之前（请参见本节末尾的更新），在使用闭包进行并发时可能会产生一些混淆。考虑以下程序：

```go
func main() {
    done := make(chan bool)
    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }
    // 等待所有goroutine完成后再退出
    for _ = range values {
        <-done
    }
}
```

有人可能会错误地期望看到输出a, b, c。但你很可能看到的是c, c, c。这是因为循环的每次迭代都使用了变量v的同一个实例，所以每个闭包都共享这个单一变量。当闭包运行时，它打印的是`fmt.Println`执行时v的值，但v可能自goroutine启动以来已经被修改了。为了帮助在问题发生前检测到此问题及其他问题，请运行`go vet`。

要在每次启动闭包时将v的当前值绑定到其中，必须修改内部循环以在每次迭代时创建一个新变量。一种方法是将变量作为参数传递给闭包：

```go
    for _, v := range values {
        go func(u string) {
            fmt.Println(u)
            done <- true
        }(v)
    }
```

在此示例中，v的值作为参数传递给匿名函数。该值然后可以在函数内作为变量u访问。

甚至更简单的方法是直接创建一个新变量，使用一种在Go中可能看起来奇怪但完全可行的声明风格：

```go
    for _, v := range values {
        v := v // 创建一个新的'v'。
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }
```

语言的这种行为，即不在每次迭代中定义一个新变量，在事后被认为是错误的，已在Go 1.22中得到解决，Go 1.22确实在每次迭代中创建一个新变量，消除了这个问题。

#### 控制流

**为什么Go没有?:运算符？**

Go中没有三元测试操作。您可以使用以下方法来达到相同的效果：

```go
if expr {
    n = trueVal
} else {
    n = falseVal
}
```

Go中没有?:运算符的原因是，语言的设计者看到这个操作被使用得过于频繁，从而创建了难以理解的复杂表达式。if-else形式虽然更长，但毫无疑问更清晰。一种语言只需要一个条件控制流结构。

#### 类型参数

**为什么Go有类型参数？**

类型参数允许所谓的泛型编程，即函数和数据结构根据在以后使用这些函数和数据结构时才指定的类型来定义。例如，它们使得编写一个返回任何有序类型的两个值中较小值的函数成为可能，而无需为每种可能的类型编写单独的版本。有关带示例的更深入解释，请参见博客文章《为什么需要泛型？》。

**Go中的泛型是如何实现的？**

编译器可以选择为每次实例化单独编译，或者为相似的实例化编译为单一实现。单一实现的方法类似于带有接口参数的函数。不同的编译器会为不同情况做出不同的选择。标准Go编译器通常为每个具有相同“形状”的类型参数发出一个单一的实例化，其中“形状”由类型的属性（如其包含的指针的大小和位置）决定。未来的版本可能会在编译时间、运行时效率和代码大小之间的权衡上进行实验。

**Go中的泛型与其他语言中的泛型相比如何？**

所有语言的基本功能是相似的：可以编写使用在以后指定的类型的类型和函数。话虽如此，还是有一些差异。

**Java**

在Java中，编译器在编译时检查泛型类型，但在运行时移除这些类型。这被称为类型擦除。例如，一个在编译时称为`List<Integer>`的Java类型在运行时会变成非泛型类型`List`。这意味着，例如，当使用Java形式的类型反射时，无法区分`List<Integer>`类型的值和`List<Float>`类型的值。在Go中，泛型类型的反射信息包含了完整的编译时类型信息。

Java使用类型通配符，如`List<? extends Number>`或`List<? super Number>`来实现泛型的协变和逆变。Go没有这些概念，这使得Go中的泛型类型简单得多。

**C++**

传统上，C++模板不对类型参数施加任何约束，尽管C++20通过概念（concepts）支持可选约束。在Go中，所有类型参数都必须有约束。C++20的概念是用必须能用类型参数编译的小代码片段来表达的。Go的约束是定义所有允许的类型参数集合的接口类型。

C++支持模板元编程；Go不支持。实际上，所有C++编译器都在实例化点编译每个模板；如上所述，Go可以并且确实对不同的实例化使用不同的方法。

**Rust**

Rust版本的约束被称为trait bounds。在Rust中，trait bound与类型之间的关联必须显式定义，要么在定义trait bound的crate中，要么在定义类型的crate中。在Go中，类型参数隐式地满足约束，就像Go类型隐式地实现接口类型一样。Rust标准库为比较或加法等操作定义了标准trait；Go标准库没有，因为这些可以通过用户代码中的接口类型来表达。唯一的例外是Go的预定义接口`comparable`，它捕获了类型系统中无法表达的属性。

**Python**

Python不是一种静态类型语言，因此可以说所有Python函数默认都是泛型的：它们总是可以用任何类型的值调用，任何类型错误都在运行时检测到。

**为什么Go在类型参数列表中使用方括号？**

Java和C++在类型参数列表中使用尖括号，如Java中的`List<Integer>`和C++中的`std::vector<int>`。然而，这个选项对Go来说不可用，因为它会导致语法问题：当在函数内解析代码时，例如`v := F<T>`，在看到`<`的那一刻，无法确定我们是看到一个实例化还是一个使用`<`操作符的表达式。如果没有类型信息，这很难解决。

例如，考虑像

```go
    a, b = w < x, y > (z)
```

这样的语句。没有类型信息，就无法决定赋值右侧是两个表达式（`w < x` 和 `y > z`），还是一个返回两个结果值的泛型函数实例化和调用（`(w<x, y>)(z)`）。

Go的一个关键设计决策是，可以在没有类型信息的情况下进行解析，而如果使用尖括号表示泛型，这似乎是不可能的。

Go在使用方括号方面并非独创；还有其他语言，如Scala，也使用方括号表示泛型代码。

**为什么Go不支持带类型参数的方法？**

Go允许泛型类型拥有方法，但除了接收者之外，这些方法的参数不能使用参数化类型。我们不认为Go将来会添加泛型方法。

问题是如何实现它们。具体来说，考虑检查接口中的一个值是否实现了另一个具有额外方法的接口。例如，考虑这个类型，一个带有泛型Nop方法的空结构体，该方法返回其参数，适用于任何可能的类型：

```go
type Empty struct{}
func (Empty) Nop[T any](x T) T {
    return x
}
```

现在假设一个Empty值被存储在一个`any`中并传递给其他检查它能做什么的代码：

```go
func TryNops(x any) {
    if x, ok := x.(interface{ Nop(string) string }); ok {
        fmt.Printf("string %s\n", x.Nop("hello"))
    }
    if x, ok := x.(interface{ Nop(int) int }); ok {
        fmt.Printf("int %d\n", x.Nop(42))
    }
    if x, ok := x.(interface{ Nop(io.Reader) io.Reader }); ok {
        data, err := io.ReadAll(x.Nop(strings.NewReader("hello world")))
        fmt.Printf("reader %q %v\n", data, err)
    }
}
```

如果x是Empty，这段代码如何工作？似乎x必须满足所有三个测试，以及任何其他类型的任何其他形式。

当这些方法被调用时，运行的是什么代码？对于非泛型方法，编译器会生成所有方法实现的代码并将其链接到最终程序中。但对于泛型方法，可能会有无限多的方法实现，因此需要不同的策略。

有四种选择：

1.  在链接时，列出所有可能的动态接口检查，然后查找那些会满足这些检查但缺少编译方法的类型，然后重新调用编译器来添加这些方法。
    这会使构建显著变慢，因为它需要在链接后停止并重复一些编译。它尤其会减慢增量构建。更糟的是，新编译的方法代码本身可能有新的动态接口检查，这个过程必须重复。可以构造出永不终止的例子。
2.  实现某种JIT，在运行时编译所需的方法代码。
    Go从纯粹的提前编译（ahead-of-time compiled）带来的简单性和可预测的性能中获益良多。我们不愿意仅仅为了实现一个语言特性就承担JIT的复杂性。
3.  安排为每个泛型方法发出一个慢速的后备实现，该实现使用一个包含类型参数上所有可能语言操作的函数表，然后对动态测试使用该后备实现。
    这种方法会使参数化为意外类型的泛型方法比参数化为编译时观察到的类型的相同方法慢得多。这会使性能变得不可预测。
4.  定义泛型方法根本不能用于满足接口。
    接口是Go编程中必不可少的部分。从设计角度来看，不允许泛型方法满足接口是不可接受的。

这些选择都不是好选择，所以我们选择了“以上都不是”。

作为带类型参数的方法的替代方案，使用带类型参数的顶层函数，或将类型参数添加到接收者类型上。

更多细节，包括更多示例，请参见提案。

**为什么我不能在参数化类型的接收者上使用更具体的类型？**

泛型类型的方法声明是用包含类型参数名称的接收者编写的。也许是因为在调用点指定类型的语法相似，有些人认为这提供了一种通过在接收者中命名特定类型（如string）来为某些类型参数生成定制方法的机制：

```go
type S[T any] struct { f T }
func (s S[string]) Add(t string) string {
    return s.f + t
}
```

这会失败，因为编译器会将`string`一词视为方法中类型参数的名称。编译器错误信息会是类似“操作符+未定义在s.f（string类型的变量）上”的内容。这可能会令人困惑，因为+操作符在预声明的类型string上完全可以工作，但该声明对于此方法覆盖了string的定义，而操作符不适用于这个无关版本的string。覆盖像这样预声明的名称是有效的，但是一件奇怪的事情，通常是一个错误。

**为什么编译器不能推断出我程序中的类型参数？**

有很多情况下，程序员可以很容易地看出泛型类型或函数的类型参数必须是什么，但语言不允许编译器推断它。类型推断是故意受限的，以确保对推断出的类型绝不会有任何混淆。其他语言的经验表明，意外的类型推断可能会在阅读和调试程序时导致相当大的困惑。总是可以指定调用中要使用的显式类型参数。未来可能会支持新的推断形式，只要规则保持简单和清晰。

#### 包和测试

**如何创建一个多文件包？**

将包的所有源文件放在一个单独的目录中。源文件可以随意引用不同文件中的项目；不需要前向声明或头文件。

除了被分成多个文件外，该包的编译和测试方式与单文件包完全一样。

**如何编写单元测试？**

在与包源文件相同的目录中创建一个以`_test.go`结尾的新文件。在该文件中，导入`"testing"`并编写如下形式的函数：

```go
func TestFoo(t *testing.T) {
    ...
}
```

在该目录中运行`go test`。该脚本会找到Test函数，构建一个测试二进制文件并运行它。

更多详情请参见《如何编写Go代码》文档、`testing`包和`go test`子命令。

**我最喜欢的测试辅助函数在哪里？**

Go的标准测试包使编写单元测试变得容易，但它缺少其他语言测试框架提供的功能，如断言函数。本文档前面的一个部分解释了为什么Go没有断言，同样的论点也适用于在测试中使用assert。适当的错误处理意味着在一个测试失败后让其他测试继续运行，这样调试失败的人就能得到一个完整的错误图景。报告isPrime对2、3、5和7（或对2、4、8和16）给出错误答案，比报告isPrime对2给出错误答案因此不再运行更多测试要有用得多。触发测试失败的程序员可能不熟悉失败的代码。现在花时间编写一个好的错误信息，日后测试出错时就会得到回报。

一个相关的观点是，测试框架往往会发展成自己的迷你语言，带有条件、控制和打印机制，但Go已经拥有所有这些功能；为什么还要重新创建它们？我们宁愿用Go编写测试；这少学一门语言，而且这种方法让测试保持直接和易于理解。

如果编写好错误所需的额外代码看起来重复且繁重，那么表驱动（table-driven）的测试可能会更好，它在一个数据结构中定义的输入和输出列表上进行迭代（Go对数据结构字面量有出色的支持）。编写好测试和好错误信息的工作将在许多测试用例上分摊。标准Go库中充满了说明性的例子，比如fmt包的格式化测试。

**为什么标准库中没有X？**

标准库的目的是支持运行时库，连接到操作系统，并提供许多Go程序所需的关键功能，如格式化I/O和网络。它还包含对Web编程重要的元素，包括加密和对HTTP、JSON和XML等标准的支持。

没有明确定义什么被包含的标准，因为很长一段时间以来，这是唯一的Go库。然而，今天添加新内容是有标准的。

向标准库添加新内容是罕见的，准入门槛很高。包含在标准库中的代码承担着巨大的持续维护成本（通常由原始作者以外的人承担），受Go 1兼容性承诺的约束（阻止修复API中的任何缺陷），并且受Go发布计划的约束，阻止用户快速获得bug修复。

大多数新代码应该存在于标准库之外，并通过go工具的`go get`命令访问。这样的代码可以有自己的维护者、发布周期和兼容性保证。用户可以在pkg.go.dev上找到包并阅读其文档。

尽管标准库中有一些实际上不属于它的部分，如`log/syslog`，但由于Go 1兼容性承诺，我们仍在继续维护库中的所有内容。但我们鼓励大多数新代码存在于别处。

#### 实现

**构建编译器使用了哪些编译器技术？**

有几种用于Go的生产编译器，以及为各种平台开发的其他几种。

默认编译器`gc`包含在Go发行版中，作为对`go`命令支持的一部分。`gc`最初是用C编写的，因为引导（bootstrapping）存在困难——您需要一个Go编译器来设置Go环境。但技术已经进步，自Go 1.5版本起，编译器已经成为一个Go程序。编译器是使用自动翻译工具从C转换为Go的，如这份设计文档和演讲中所述。因此，编译器现在是“自举的”（self-hosting），这意味着我们需要面对引导问题。解决方案是已经有一个可用的Go安装，就像通常有一个可用的C安装一样。如何从源码启动一个新的Go环境的故事在这里和这里描述。

`gc`是用Go编写的，使用递归下降解析器，并使用一个自定义加载器（也用Go编写，但基于Plan 9加载器）来生成ELF/Mach-O/PE二进制文件。

`gccgo`编译器是用C++编写的前端，带有递归下降解析器，与标准的GCC后端耦合。一个实验性的LLVM后端正在使用相同的前端。

在项目开始时，我们考虑过在`gc`中使用LLVM，但决定它太大太慢，无法满足我们的性能目标。更重要的是，事后看来，从LLVM开始会让引入一些ABI和相关变更（如栈管理）变得更难，而这些是Go需要但不属于标准C设置的。

事实证明，Go是实现Go编译器的一种绝佳语言，尽管这并非它的最初目标。从一开始就不自举，使得Go的设计可以专注于其最初的用例，即网络服务器。如果我们一开始就决定Go应该编译自己，我们最终可能会得到一门更针对编译器构建的语言，这是一个值得的目标，但不是我们最初的目标。

尽管`gc`有自己的实现，但`go/parser`包中提供了原生的词法分析器和解析器，还有一个原生的类型检查器。`gc`编译器使用这些库的变体。

**运行时支持是如何实现的？**

再次由于引导问题，运行时代码最初主要是用C（加上少量汇编）编写的，但后来被翻译成了Go（除了少量汇编部分）。`gccgo`的运行时支持使用`glibc`。`gccgo`编译器使用一种称为分段栈（segmented stacks）的技术来实现goroutine，该技术由对gold链接器的近期修改支持。`gollvm`类似地构建在相应的LLVM基础设施上。

**为什么我的简单程序是这么大的二进制文件？**

`gc`工具链中的链接器默认创建静态链接的二进制文件。因此，所有Go二进制文件都包含Go运行时，以及支持动态类型检查、反射甚至panic时栈追踪所必需的运行时类型信息。

在Linux上使用gcc静态编译和链接的简单C“hello, world”程序大约为750 kB，其中包括printf的实现。使用`fmt.Printf`的等效Go程序重几兆字节，但这包括了更强大的运行时支持和类型及调试信息。

用`gc`编译的Go程序可以用`-ldflags=-w`标志链接，以禁用DWARF生成，从二进制文件中移除调试信息，而不会损失其他功能。这可以显著减小二进制文件的大小。

**我能阻止这些关于未使用变量/导入的抱怨吗？**

未使用的变量可能表示一个bug，而未使用的导入只会减慢编译速度，随着程序积累代码和程序员的更替，这种影响可能会变得相当可观。出于这些原因，Go拒绝编译包含未使用变量或导入的程序，以短期的便利换取长期的构建速度和程序清晰度。

尽管如此，在开发代码时，暂时创建这些情况是很常见的，而必须在程序编译前编辑掉它们可能会很烦人。

有些人要求添加一个编译器选项来关闭这些检查，或至少将其降级为警告。然而，这个选项没有被添加，因为编译器选项不应影响语言的语义，而且Go编译器不报告警告，只报告阻止编译的错误。

不过，解决这个问题很容易。使用空白标识符（blank identifier）可以让未使用的东西在您开发时保持存在。

```go
import "unused"
// 此声明通过引用包中的一个项目来标记导入为已使用。
var _ = unused.Item  // TODO: 提交前删除！
func main() {
    debugData := debug.Profile()
    _ = debugData // 仅在调试期间使用。
    ....
}
```

如今，大多数Go程序员使用`goimports`工具，它会自动重写Go源文件以拥有正确的导入，实际上消除了未使用导入的问题。该程序可以轻松地连接到大多数编辑器和IDE，在编写Go源文件时自动运行。此功能也已集成到`gopls`中，如上所述。

**为什么我的病毒扫描软件认为我的Go发行版或编译的二进制文件被感染了？**

这是一个常见现象，尤其是在Windows机器上，几乎总是误报。商业病毒扫描程序经常被Go二进制文件的结构搞糊涂，因为它们不像其他语言编译的二进制文件那样常见。

如果您刚刚安装了Go发行版而系统报告它被感染了，那肯定是弄错了。为了彻底验证，您可以通过将校验和与下载页面上的校验和进行比较来验证下载。

无论如何，如果您认为报告有误，请向您的病毒扫描程序供应商报告一个bug。也许随着时间的推移，病毒扫描器能学会理解Go程序。

#### 性能

**为什么Go在基准测试X上表现不佳？**

Go的设计目标之一是接近C在可比程序上的性能，但在某些基准测试上，它的表现却很差，包括golang.org/x/exp/shootout中的几个。表现最差的依赖于Go中没有性能相当版本的库。例如，`pidigits.go`依赖于一个任意精度的数学包，而C版本（与Go不同）使用GMP（用优化的汇编编写）。依赖正则表达式（例如`regex-dna.go`）的基准测试本质上是在比较Go的原生regexp包与成熟、高度优化的正则表达式库（如PCRE）。

基准测试游戏是通过大量调优赢得的，而大多数Go版本的基准测试都需要关注。如果您测量真正可比的C和Go程序（`reverse-complement.go`就是一个例子），您会发现这两种语言在原始性能上比这个套件所显示的要接近得多。

尽管如此，仍有改进的空间。编译器不错，但还可以更好，许多库需要重大的性能工作，垃圾回收器还不够快。（即使它够快了，注意不要产生不必要的垃圾也能产生巨大影响。）

无论如何，Go通常可以非常有竞争力。随着语言和工具的发展，许多程序的性能已经有了显著提升。请参阅关于剖析Go程序的博客文章，以获得一个有启发性的例子。它很老了，但仍然包含有用的信息。

#### 与C的差异

**为什么语法与C如此不同？**

除了声明语法外，差异并不大，源于两个愿望。首先，语法应该感觉轻量，没有太多强制性的关键字、重复或晦涩难懂的东西。其次，该语言被设计为易于分析，可以在没有符号表的情况下进行解析。这使得构建调试器、依赖分析器、自动化文档提取器、IDE插件等工具变得容易得多。C及其后代在这方面以难以处理而臭名昭著。

**为什么声明是“反向”的？**

只有当你习惯了C才会觉得它们是反向的。在C中，概念是变量的声明方式类似于表示其类型的表达式，这是一个好主意，但类型和表达式的语法混合得不太好，结果可能会令人困惑；想想函数指针。Go大多将表达式和类型语法分开，这简化了事情（使用前缀`*`表示指针是证明规则的例外）。在C中，声明

```c
    int* a, b;
```

声明a是指针，但b不是；在Go中

```go
    var a, b *int
```

声明两者都是指针。这更清晰、更规则。此外，`:=`短声明形式表明，完整的变量声明应该呈现与`:=`相同的顺序，因此

```go
    var a uint64 = 1
```

与

```go
    a := uint64(1)
```

效果相同。通过拥有独立于表达式语法的类型语法，解析也得到了简化；`func`和`chan`等关键字使事情变得清晰。

更多细节请参见关于Go声明语法的文章。

**为什么没有指针算术？**

为了安全。没有指针算术，就有可能创建一种语言，它永远无法派生出非法地址而错误地成功。编译器和硬件技术已经发展到这样的程度：使用数组索引的循环可以和使用指针算术的循环一样高效。此外，缺乏指针算术可以简化垃圾回收器的实现。

**为什么++和--是语句而不是表达式？以及为什么是后缀，而不是前缀？**

没有指针算术，前置和后置自增操作符的便利价值就降低了。通过将它们完全从表达式层次结构中移除，表达式语法得以简化，也消除了围绕++和--的求值顺序的混乱问题（考虑`f(i++)`和`p[i] = q[++i]`）。这种简化是显著的。至于后缀与前缀，两者都可以，但后缀版本更传统；对前缀的坚持源于STL，一个库的名字中包含一个后缀自增操作符，这颇具讽刺意味。

**为什么有大括号却没有分号？以及为什么不能把左大括号放在下一行？**

Go使用大括号进行语句分组，这种语法对于使用过C语言家族任何语言的程序员来说都很熟悉。然而，分号是给解析器用的，不是给人用的，我们希望尽可能消除它们。为了实现这个目标，Go借鉴了BCPL的一个技巧：分隔语句的分号在正式语法中存在，但由词法分析器在任何可能作为语句结尾的行末自动插入，无需前瞻。这在实践中效果很好，但有一个副作用，那就是它强制了一种花括号风格。例如，函数的左大括号不能单独出现在一行上。

有些人认为词法分析器应该进行前瞻，以允许花括号放在下一行。我们不同意。由于Go代码旨在由`gofmt`自动格式化，因此必须选择一种风格。这种风格可能与您在C或Java中使用的不同，但Go是一种不同的语言，`gofmt`的风格和其他任何风格一样好。更重要的是——更重要得多——所有Go程序都遵循单一的、程序强制规定的格式所带来的优势，远远超过了对特定风格的任何感知上的劣势。还要注意，Go的风格意味着交互式Go实现可以一次一行地使用标准语法，而不需要特殊规则。

**为什么要进行垃圾回收？不会太昂贵吗？**

系统程序中簿记的最大来源之一是管理已分配对象的生命周期。在像C这样需要手动管理的语言中，这会消耗程序员大量的时间，并且常常是顽固bug的根源。即使在像C++或Rust这样提供机制来辅助的语言中，这些机制也可能对软件设计产生重大影响，通常会增加编程开销。我们认为消除程序员的这些开销至关重要，而近年来垃圾回收技术的进步让我们有信心，它可以以足够低的成本和足够低的延迟实现，使其成为网络化系统的可行方案。

并发编程的大部分困难根源在于对象生命周期问题：当对象在多个线程间传递时，保证它们被安全释放会变得繁琐。自动垃圾回收使得编写并发代码变得容易得多。当然，在并发环境中实现垃圾回收本身就是一个挑战，但一次性解决它而不是在每个程序中都解决，对每个人都有帮助。

最后，抛开并发不谈，垃圾回收使接口更简单，因为它们不需要指定跨接口的内存管理方式。

这并不是说像Rust这样的语言在管理资源问题上带来新思想的近期工作是误导的；我们鼓励这项工作，并兴奋地看到它如何发展。但Go采取了更传统的方法，通过垃圾回收来解决对象生命周期问题，仅此而已。

当前的实现是标记-清除（mark-and-sweep）收集器。如果机器是多处理器，收集器会在与主程序并行的单独CPU核心上运行。近年来在收集器上的大量工作已将暂停时间通常减少到亚毫秒级别，即使对于大型堆也是如此，这几乎消除了对网络服务器中垃圾回收的主要反对意见之一。工作仍在继续，以进一步完善算法、减少开销和延迟，并探索新方法。Go团队的Rick Hudson在2018年ISMM主题演讲中描述了迄今为止的进展，并提出了未来的一些方法。

关于性能，请记住，Go为程序员提供了对内存布局和分配的相当大的控制，这比典型的垃圾回收语言要多得多。细心的程序员可以通过良好地使用语言来极大地减少垃圾回收的开销；请参见关于剖析Go程序的文章，其中有一个实例演示，包括Go剖析工具的演示。



> **[↩ 返回到目录](doc.md)**















