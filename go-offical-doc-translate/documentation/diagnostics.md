> **[↩ 返回到目录](doc.md)**


---

### 诊断

#### 目录
*   介绍
*   性能分析 (Profiling)
*   跟踪 (Tracing)
*   调试 (Debuging)
*   运行时统计和事件
*   执行跟踪器
*   GODEBUG

#### 介绍
Go 生态系统提供了一套庞大的 API 和工具，用于诊断 Go 程序中的逻辑和性能问题。本文总结了可用的工具，并帮助 Go 用户为他们的特定问题选择合适的工具。

诊断解决方案可以分为以下几类：
*   **性能分析 (Profiling)**：性能分析工具分析 Go 程序的复杂性和开销，例如其内存使用情况和频繁调用的函数，以识别 Go 程序中开销大的部分。
*   **跟踪 (Tracing)**：跟踪是一种对代码进行插桩以分析调用或用户请求整个生命周期内延迟的方法。跟踪提供了系统中每个组件对整体延迟的贡献概览。跟踪可以跨越多个 Go 进程。
*   **调试 (Debugging)**：调试允许我们暂停 Go 程序并检查其执行情况。可以使用调试来验证程序状态和执行流程。
*   **运行时统计和事件**：收集和分析运行时统计信息和事件，可以提供 Go 程序健康状况的高级概览。指标的峰值/低谷有助于我们识别吞吐量、利用率和性能的变化。

**注意**：某些诊断工具可能会相互干扰。例如，精确的内存分析会扭曲 CPU 分析结果，而 goroutine 阻塞分析会影响调度器跟踪。建议单独使用工具以获得更精确的信息。

#### 性能分析
性能分析对于识别开销大或频繁调用的代码段很有用。Go 运行时提供符合 `pprof` 可视化工具预期格式的分析数据。分析数据可以通过 `go test` 在测试期间收集，也可以通过 `net/http/pprof` 包提供的端点获取。用户需要收集分析数据，并使用 pprof 工具来过滤和可视化顶级代码路径。

`runtime/pprof` 包提供的预定义分析类型：
*   **cpu**：CPU 分析确定程序在主动消耗 CPU 周期时（而不是在睡眠或等待 I/O 时）将时间花费在何处。
*   **heap**：堆分析报告内存分配样本；用于监控当前和历史内存使用情况，并检查内存泄漏。
*   **threadcreate**：线程创建分析报告导致创建新操作系统线程的程序部分。
*   **goroutine**：goroutine 分析报告所有当前 goroutine 的堆栈跟踪。
*   **block**：阻塞分析显示 goroutine 在同步原语（包括定时器通道）上等待阻塞的位置。阻塞分析默认不启用；使用 `runtime.SetBlockProfileRate` 来启用。
*   **mutex**：互斥锁分析报告锁争用情况。当你认为由于互斥锁争用导致 CPU 未得到充分利用时，使用此分析。互斥锁分析默认不启用，参见 `runtime.SetMutexProfileFraction` 以启用。

**我还能用其他分析器来分析 Go 程序吗？**
在 Linux 上，可以使用 `perf` 工具来分析 Go 程序。`perf` 可以分析和展开 cgo/SWIG 代码及内核，因此对于了解原生/内核性能瓶颈很有用。在 macOS 上，可以使用 Instruments 套件来分析 Go 程序。

**我能对生产服务进行性能分析吗？**
可以。在生产环境中对程序进行性能分析是安全的，但启用某些分析（例如 CPU 分析）会增加开销。你应该预期会看到性能下降。可以在生产环境启用分析之前，通过测量分析器的开销来估算性能损失。

你可能希望定期对生产服务进行性能分析。尤其是在拥有大量单个进程副本的系统中，定期选择一个随机副本是安全的选项。选择一个生产进程，每 Y 秒对其进行 X 秒的分析，并将结果保存用于可视化和分析；然后定期重复此过程。结果可以手动和/或自动审查以发现问题。收集分析数据可能会相互干扰，因此建议一次只收集一个分析。

**可视化分析数据的最佳方法是什么？**
Go 工具通过 `go tool pprof` 提供了文本、图形和 callgrind 格式的分析数据可视化。阅读《分析 Go 程序》以了解它们的实际应用。
*   以文本形式列出开销最大的调用。
*   以图形形式可视化开销最大的调用。
*   Weblist 视图在 HTML 页面中逐行显示源代码的开销部分。在以下示例中，530ms 的时间花费在 `runtime.concatstrings` 上，每行的开销在列表中显示。
*   以 Weblist 形式可视化开销最大的调用。

另一种可视化分析数据的方法是火焰图（flame graph）。火焰图允许你沿着特定的调用路径移动，因此可以放大/缩小代码的特定部分。上游的 pprof 支持火焰图。
*   火焰图提供可视化，以发现开销最大的代码路径。

**我是否仅限于内置的分析类型？**
除了 `runtime` 包提供的功能外，Go 用户还可以通过 `pprof.Profile` 创建自定义分析，并使用现有工具来检查它们。

**我能否在不同的路径和端口上提供分析器处理程序（/debug/pprof/...）？**
可以。`net/http/pprof` 包默认将其处理程序注册到默认的多路复用器（mux）上，但你也可以通过使用该包导出的处理程序来自己注册它们。

例如，以下示例将在 `:7777` 端口的 `/custom_debug_path/profile` 路径上提供 `pprof.Profile` 处理程序：
```go
package main

import (
	"log"
	"net/http"
	"net/http/pprof"
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/custom_debug_path/profile", pprof.Profile)
	log.Fatal(http.ListenAndServe(":7777", mux))
}
```

#### 跟踪
跟踪是一种对代码进行插桩以分析调用链整个生命周期内延迟的方法。Go 提供了 `golang.org/x/net/trace` 包，作为每个 Go 节点的最小跟踪后端，并提供了一个带有简单仪表板的最小化插桩库。Go 还提供了一个执行跟踪器，用于在特定时间间隔内跟踪运行时事件。

跟踪使我们能够：
*   在 Go 进程中插桩和分析应用程序延迟。
*   测量长调用链中特定调用的开销。
*   找出利用率和性能改进点。没有跟踪数据，瓶颈并不总是显而易见的。

在单体系统中，从程序的构建模块中收集诊断数据相对容易。所有模块都存在于一个进程中，并共享共同的资源来报告日志、错误和其他诊断信息。一旦你的系统规模超过单个进程并开始变得分布式，就很难跟踪一个调用从前端 Web 服务器开始，经过所有后端，直到响应返回给用户。这就是分布式跟踪在插桩和分析生产系统中发挥重要作用的地方。

分布式跟踪是一种对代码进行插桩以分析用户请求整个生命周期内延迟的方法。当系统是分布式的，并且传统的性能分析和调试工具无法扩展时，你可能希望使用分布式跟踪工具来分析用户请求和 RPC 的性能。

分布式跟踪使我们能够：
*   在大型系统中插桩和分析应用程序延迟。
*   跟踪用户请求生命周期内的所有 RPC，并发现只有在生产环境中才可见的集成问题。
*   找出可以应用到我们系统上的性能改进点。许多瓶颈在收集跟踪数据之前并不明显。

Go 生态系统为不同的跟踪系统提供了各种分布式跟踪库，以及与后端无关的库。

**有没有办法自动拦截每次函数调用并创建跟踪？**
Go 没有提供自动拦截每次函数调用并创建跟踪片段（span）的方法。你需要手动对代码进行插桩来创建、结束和注释片段。

**我应该如何在 Go 库中传播跟踪头信息？**
你可以在 `context.Context` 中传播跟踪标识符和标签。目前行业中还没有标准的跟踪键或通用的跟踪头表示方法。每个跟踪提供商负责在其 Go 库中提供传播工具。

**标准库或运行时中还有哪些其他低级事件可以包含在跟踪中？**
标准库和运行时正努力暴露更多 API 来通知低级别的内部事件。例如，`httptrace.ClientTrace` 提供了 API 来跟踪出站请求生命周期中的低级别事件。目前正在进行一项工作，以从运行时执行跟踪器中获取低级别的运行时事件，并允许用户定义和记录他们自己的用户事件。

#### 调试
调试是识别程序为何行为异常的过程。调试器允许我们了解程序的执行流程和当前状态。有多种调试方式；本节将只关注将调试器附加到程序和核心转储（core dump）调试。

Go 用户主要使用以下调试器：
*   **Delve**：Delve 是 Go 编程语言的调试器。它支持 Go 的运行时概念和内置类型。Delve 力求成为 Go 程序的全功能、可靠的调试器。
*   **GDB**：Go 通过标准 Go 编译器和 Gccgo 提供 GDB 支持。由于栈管理、线程和运行时与 GDB 期望的执行模型存在足够大的差异，即使程序是用 gccgo 编译的，也可能使调试器感到困惑。尽管可以使用 GDB 来调试 Go 程序，但它并不理想，可能会造成混淆。

**调试器对 Go 程序的支持效果如何？**
`gc` 编译器会执行诸如函数内联和变量寄存器化等优化。这些优化有时会使使用调试器进行调试变得更加困难。目前正在进行一项工作，以改进为优化二进制文件生成的 DWARF 信息的质量。在这些改进可用之前，我们建议在构建被调试代码时禁用优化。以下命令以无编译器优化的方式构建一个包：
```bash
$ go build -gcflags=all="-N -l"
```

作为改进工作的一部分，Go 1.10 引入了一个新的编译器标志 `-dwarflocationlists`。该标志会导致编译器添加位置列表，帮助调试器处理优化后的二进制文件。以下命令以优化方式构建一个包，但包含 DWARF 位置列表：
```bash
$ go build -gcflags="-dwarflocationlists=true"
```

**推荐的调试器用户界面是什么？**
尽管 `delve` 和 `gdb` 都提供了命令行界面（CLI），但大多数编辑器集成和 IDE 都提供了特定于调试的用户界面。

**是否可以对 Go 程序进行事后调试（postmortem debugging）？**
核心转储文件是包含运行中进程的内存转储及其进程状态的文件。它主要用于程序的事后调试，以及在程序仍在运行时了解其状态。这两种情况使得核心转储的调试成为事后分析和诊断生产服务的良好辅助手段。可以从 Go 程序获取核心文件，并使用 `delve` 或 `gdb` 进行调试，参见[核心转储调试页面](https://github.com/go-delve/delve/blob/master/Documentation/usage/core_dump_debugging.md)以获取分步指南。

#### 运行时统计和事件
运行时提供内部事件的统计和报告，供用户诊断运行时级别的性能和利用率问题。

用户可以监控这些统计数据，以更好地了解 Go 程序的整体健康状况和性能。一些经常监控的统计数据和状态：
*   `runtime.ReadMemStats` 报告与堆分配和垃圾回收相关的指标。内存统计数据对于监控进程消耗了多少内存资源、进程是否能有效利用内存以及检测内存泄漏很有用。
*   `debug.ReadGCStats` 读取有关垃圾回收的统计数据。它有助于了解在 GC 暂停上花费了多少资源。它还报告了垃圾回收器暂停的时间线和暂停时间百分位数。
*   `debug.Stack` 返回当前的堆栈跟踪。堆栈跟踪有助于了解当前正在运行多少 goroutine、它们在做什么以及它们是否被阻塞。
*   `debug.WriteHeapDump` 暂停所有 goroutine 的执行，并允许你将堆转储到文件中。堆转储是 Go 进程在特定时间点的内存快照。它包含所有已分配的对象以及 goroutine、终结器等。
*   `runtime.NumGoroutine` 返回当前 goroutine 的数量。该值可以被监控，以查看是否充分利用了足够的 goroutine，或检测 goroutine 泄漏。

#### 执行跟踪器
Go 自带一个运行时执行跟踪器，用于捕获各种运行时事件。调度、系统调用、垃圾回收、堆大小和其他事件由运行时收集，并可通过 `go tool trace` 进行可视化。执行跟踪器是检测延迟和利用率问题的工具。你可以检查 CPU 的利用效率，以及网络或系统调用何时导致 goroutine 被抢占。

跟踪器对于以下情况很有用：
*   了解你的 goroutine 如何执行。
*   了解一些核心运行时事件，例如 GC 运行。
*   识别并行化不佳的执行。

然而，它并不擅长识别热点，例如分析内存或 CPU 使用过多的原因。请先使用性能分析工具来解决这些问题。

上图中，`go tool trace` 的可视化显示执行开始时正常，然后变得串行化。这表明可能存在对共享资源的锁争用，从而造成瓶颈。

参见 `go tool trace` 以收集和分析运行时跟踪。

#### GODEBUG
如果设置了 `GODEBUG` 环境变量，运行时也会发出事件和信息。

*   `GODEBUG=gctrace=1` 在每次垃圾回收时打印垃圾回收事件，总结收集的内存量和暂停的时长。
*   `GODEBUG=inittrace=1` 打印已完成的包初始化工作的执行时间和内存分配信息摘要。
*   `GODEBUG=schedtrace=X` 每 X 毫秒打印一次调度事件。

`GODEBUG` 环境变量可用于在标准库和运行时中禁用指令集扩展的使用。
*   `GODEBUG=cpu.all=off` 禁用所有可选指令集扩展的使用。
*   `GODEBUG=cpu.extension=off` 禁用来自指定指令集扩展的指令的使用。
    *   `extension` 是指令集扩展的小写名称，例如 `sse41` 或 `avx`。

> **[↩ 返回到目录](doc.md)**
